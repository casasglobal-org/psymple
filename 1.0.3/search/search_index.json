{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>psymple</code> is a package designed for general complex systems modelling. A complex system is a dynamic system whose interconnectivity produces non-trivial or unexpected behaviour. Examples of complex systems exist everywhere, from ecological systems, chemical reactions, economic systems, astronomy and even social networks.</p> <p>The sections below give a wide introduction to the structure of <code>psymple</code>, why it exists, how to use it, and how to get involved.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>psymple</code> is a Python package currently supporting versions <code>3.10</code> and higher. </p> <p>The latest version of <code>psymple</code> is available on PyPI and can be installed with <code>pip</code>.</p> <pre><code>pip install psymple\n</code></pre> <p><code>psymple</code> includes automated tests. More information can be found on the testing page.</p>"},{"location":"#where-to-start","title":"Where to start","text":"<p>For most new users, going through the following resources in the suggested order will provide a good introduction to <code>psymple</code>. </p> <ul> <li> <p> Why psymple exists</p> <p>Find out about the purpose and design principles of <code>psymple</code>.</p> <p> Read more</p> </li> <li> <p> Modelling in psymple</p> <p>Learn how to capture functions and differential equations in <code>psymple</code>, and combine these into complex models.</p> <p> Start modelling</p> </li> <li> <p> Simulating models</p> <p>Understand how to create and run simulations for <code>psymple</code> models.</p> <p> Run simulations</p> </li> <li> <p> Tutorials</p> <p>Work through full examples of implementing, parametrising and simulating models.</p> <p> See more</p> </li> <li> <p> The mathematics</p> <p>Learn more about the mathematical structures underneath psymple which tie everything together.</p> <p> See the maths</p> </li> <li> <p> Get involved</p> <p>Find out how you can get involved in the community by using or developing <code>psymple</code>.</p> <p> Get involved</p> </li> </ul>"},{"location":"#citing-psymple","title":"Citing <code>psymple</code>","text":"<p><code>psymple</code> has been peer-reviewed and published by the Journal of Open Source Software (JOSS).</p> <p>The following link will take you to the article page on JOSS where you can also access the software paper, which provides more information on the background, development and context of <code>psymple</code>. </p> <p></p> <p>For more information, including how to cite <code>psymple</code>, please visit the citations page.</p> <p>Citing psymple</p>"},{"location":"abstract/","title":"Abstract","text":""},{"location":"abstract/#psymple.abstract.SymbolWrapper","title":"<code>SymbolWrapper(symbol, description='')</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A class storing a <code>sympy.Symbol</code> instance with other attributes.</p> PARAMETER DESCRIPTION <code>symbol</code> <p>the symbol to wrap</p> <p> TYPE: <code>str | Symbol</code> </p> <code>description</code> <p>an optional description of the container contents</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>psymple/abstract.py</code> <pre><code>def __init__(self, symbol: str | Symbol, description: str = \"\"):\n    \"\"\"\n    Create a SymbolWrapper instance.\n\n    Args:\n        symbol: the symbol to wrap\n        description: an optional description of the container contents\n    \"\"\"\n    if isinstance(symbol, str):\n        symbol = Symbol(symbol)\n    self.symbol = symbol\n    self.description = description\n</code></pre>"},{"location":"components/composite_ported_objects/","title":"Defining composite models","text":"<p>A composite model consists of collections of functions and differential equations composed together by functional substitution and variable aggregation. Composite models in <code>psymple</code> are captured by composite ported objects.</p> <p>The functions and differential equations to be composed come from ported objects added as children. The ports of these child objects are then connected to the ports of the parent ported object by directed wires to capture functional substitution, and variable wires to capture variable aggregation.</p> <p>Functions and differential equations</p> <p>First read how to define functions and define ODEs as ported objects in <code>psymple</code>.</p>"},{"location":"components/composite_ported_objects/#example","title":"Example","text":"<p>A very simple problem which can be modelled in a composite ported object is the following.</p> <p>Example: projectile with air resistance</p> <p>Consider an object dropped from a height \\(h\\) at time \\(t=0\\). The object falls vertically downwards under the force of gravity with speed \\(v(t)\\), and is acted on by air resistance with magnitude</p> \\[ \\frac{1}{2}C_D \\rho A v^2 \\] <p>directed vertically upwards, where \\(C_D\\) is the drag coefficient of the object, \\(\\rho\\) is the air density, \\(A\\) is the effective surface area of the object, and \\(m\\) is its mass.</p> <p>In <code>psymple</code>, the forces acting on the falling object can be modelled individually, and then aggregated together. Let the positive direction be downwards. For the gravitational force \\(F_G = mg\\), applying Newton's second law gives \\(\\frac{dv}{dt} = g\\), while for the resistance force, \\(\\frac{dv}{dt} = - \\mu v^2\\), where \\(\\mu = \\frac{C_D \\rho A}{2m}\\). </p> <p>The following three ported objects capture the two dynamic components, and the multiplier \\(\\mu\\). See defining functions and defining ODEs for more detail.</p> falling object - components<pre><code>from psymple.build import FunctionalPortedObject, VariablePortedObject\n\nv_gravity = VariablePortedObject(\n    name=\"v_gravity\",\n    input_ports=[(\"g\", 9.81)], # (1)!\n    assignments=[(\"v\", \"g\")],\n)\n\nv_drag = VariablePortedObject(\n    name=\"v_drag\",\n    assignments=[(\"v\", \"-mu * v**2\")], # (2)!\n)\n\nf_drag = FunctionalPortedObject(\n    name=\"f_drag\",\n    assignments=[(\"mu\", \"C * rho * A / (2 * m)\")], # (3)!\n)\n</code></pre> <ol> <li> <p>The default \\(g=9.81\\) is specified here so that we don't need to worry about it later.</p> </li> <li> <p>This assignment automatically creates an input port <code>\"mu\"</code> and variable port <code>\"v\"</code> of <code>\"v_drag\"</code> to connect to.</p> </li> <li> <p>This assignment automatically creates input ports <code>[\"C\", \"rho\", \"A\", \"m\"]</code> and an output port \"<code>mu</code>\" of <code>\"f_drag\"</code> to connect to.</p> </li> </ol> <p>To create the falling object model from these components, <code>psymple</code> needs to know:</p> <ol> <li>That the variable at port <code>\"v\"</code> of <code>\"v_gravity\"</code> and the variable at port <code>\"v\"</code> of <code>\"v_drag\"</code> need to be aggregated,</li> <li>That the input <code>\"mu\"</code> of <code>\"v_drag\"</code> needs to read the output value <code>\"mu\"</code> of <code>\"f_drag\"</code>,</li> <li>How to obtain the values of the inputs <code>[\"C\", \"rho\", \"A\", \"m\"]</code> of <code>\"f_drag\"</code>. </li> </ol> <p>Referencing a child port</p> <p>The port of a child object is referenced by the string <code>\"name.port_name\"</code> where <code>name = child.name</code> is the attribute specified when instantiating that child object. This does not need to be the same as the <code>python</code> identifier.</p> <p>These are all accomplished inside this composite ported object:</p> falling object - model<pre><code>from psymple.build import CompositePortedObject\n\nmodel = CompositePortedObject(\n    name=\"model\",\n    children=[v_gravity, v_drag, f_drag], # (1)!\n    input_ports=[\"C\", \"rho\", \"A\", \"m\"],  # (2)!\n    variable_ports=[\"v\"], # (3)!\n    directed_wires=[\n        (\"C\", \"f_drag.C\"), # (4)!\n        (\"rho\", \"f_drag.rho\"),\n        (\"A\", \"f_drag.A\"),\n        (\"m\", \"f_drag.m\"),\n        (\"f_drag.mu\", \"v_drag.mu\"), # (5)! \n    ],\n    variable_wires=[\n        ([\"v_gravity.v\", \"v_drag.v\"], \"v\") # (6)!\n    ],\n)\n</code></pre> <ol> <li> <p>This imports the three ported objects from before into <code>\"model\"</code> so that their ports and assignments can be accessed.</p> </li> <li> <p>This creates a list of inputs, or model dependencies, on the outside of <code>\"model\"</code>. Adjusting these will change the behaviour of the model.</p> </li> <li> <p>This creates a variable port <code>\"v\"</code> for <code>\"model\"</code> which will access the velocity of the object.</p> </li> <li> <p>This tuple tells <code>psymple</code> to identify the value at input <code>\"C\"</code> with the value of <code>\"C\"</code> inside the assignment of <code>\"f_drag\"</code>. Similarly for the next three tuples.</p> </li> <li> <p>This tuple tells <code>psymple</code> to identify input <code>\"mu\"</code> of <code>\"v_drag\"</code> with the output value <code>\"mu\"</code> of <code>\"f_drag\"</code>.</p> </li> <li> <p>This tuple tells <code>psymple</code> to aggregate the variable at port <code>\"v\"</code> of <code>\"v_gravity\"</code> and the variable at port <code>\"v\"</code> of <code>\"v_drag\"</code> together, and expose the aggregated variable at the variable port <code>\"v\"</code> of <code>\"model\"</code>.</p> </li> </ol> <p>There are two syntaxes for specifying directed wires. The following are equivalent in this example:</p> tuple inputdictionary input <pre><code>directed_wires=[\n    (\"C\", \"f_drag.C\"), \n    (\"rho\", \"f_drag.rho\"),\n    (\"A\", \"f_drag.A\"),\n    (\"m\", \"f_drag.m\"),\n    (\"f_drag.mu\", \"v_drag.mu\"), \n],\n</code></pre> <pre><code>directed_wires=[\n    {\"source\": \"C\", \"destination\": \"f_drag.C\"}, \n    {\"source\": \"rho\", \"destination\": \"f_drag.rho\"},\n    {\"source\": \"A\", \"destination\": \"f_drag.A\"},\n    {\"source\": \"m\", \"destination\": \"f_drag.m\"},\n    {\"source\": \"f_drag.mu\", \"destination\": \"v_drag.mu\"}, \n],\n</code></pre> <p>Similarly, there are two syntaxes for specifying variable wires. The following are equivalent:</p> tuple inputdictionary input <pre><code>variable_wires=[\n    ([\"v_gravity.v\", \"v_drag.v\"], \"v\") \n],\n</code></pre> <pre><code>variable_wires=[\n    {\n        \"child_ports\": [\"v_gravity.v\", \"v_drag.v\"],\n        \"parent_port\": \"v\",\n    }\n],\n</code></pre> <p>When <code>psymple</code> builds the <code>model</code> composite ported object, it:</p> <ol> <li>Creates the input ports and variable ports specified.</li> <li>Builds a <code>DirectedWire</code> instance for each item in the argument list <code>directed_wires</code>. In doing so, it checks that all the ports exist and are of the correct type (source ports must be input ports of <code>model</code>, or output ports/variable ports of its children, and destination ports must be input ports of children, or output ports of <code>model</code>).</li> <li>Builds a <code>VariableAggregationWiring</code> instance for each item in the argument list <code>variable_wires</code>. In doing so, it checks all the ports exist and are variable ports.</li> </ol>"},{"location":"components/composite_ported_objects/#reading-variable-values-as-inputs","title":"Reading variable values as inputs","text":"<p>It is common to need to perform calculations on system variables. To facilitate this in <code>psymple</code>, instances of <code>VariablePortedObject</code> can also be given output ports for each exposed variable. A directed wire can connect to these output ports in the same way as for output ports of functional or composite ported objects.</p> <p>Example: separated growth rate</p> <p>Consider a population \\(x\\) according to the differential equation \\(\\frac{dx}{dt} = r_c x\\), where \\(r_c = 0.1\\) is the per-capita growth rate of the population.</p> <p>While this equation can be captured in a single variable ported object in <code>psymple</code>, it can also be captured as a composite ported object in which the differential equation and rate calculation are separated, as follows.</p> Separated growth rate<pre><code>from psymple.build import (\n    VariablePortedObject,\n    FunctionalPortedObject,\n    CompositePortedObject,\n)\n\npop_ode = VariablePortedObject(\n    name=\"pop_ode\",\n    assignments=[(\"x\", \"r\")] # (1)!\n)\n\ngrowth_rate = FunctionalPortedObject(\n    name=\"growth_rate\",\n    assignments=[(\"r\", \"r_c * x\")], # (2)!\n)\n\npop = CompositePortedObject(\n    name=\"pop\",\n    children=[pop_ode, growth_rate],\n    input_ports=[(\"r_c\", 0.1)],\n    variable_ports=[\"x\"],\n    directed_wires=[\n        (\"r_c\", \"growth_rate.r_c\"),\n        (\"pop_ode.x\", \"growth_rate.x\"), # (3)!\n        (\"growth_rate.r\", \"pop_ode.r\"),\n    ],\n    variable_wires=[([\"pop_ode.x\"], \"x\")] # (4)!\n)\n</code></pre> <ol> <li> <p>This specifies a generic differential equation \\(\\frac{dx}{dt} = r\\).</p> </li> <li> <p>This calculates the total rate \\(r\\) as the product of the per-capita rate \\(r_c\\) and the population variable \\(x\\).</p> </li> <li> <p>The variable <code>x</code> of <code>pop_ode</code> is read using a directed wire, and fed into the input <code>x</code> of <code>growth_rate</code>.</p> </li> <li> <p>The variable <code>x</code> of <code>pop_ode</code> can still be exposed or aggregated using variable wires.</p> </li> </ol> <p>Upon compilation, the composite object <code>pop</code> will substitute <code>r</code> for <code>r_c * x</code>, and expose the resulting assignment at the variable port <code>x</code>. </p>"},{"location":"components/composite_ported_objects/#next-steps","title":"Next steps","text":"<p>Once models are defined using composite ported objects, they can be used to define a simulable system</p>"},{"location":"components/composite_ported_objects/#notes-on-best-practice","title":"Notes on best practice","text":""},{"location":"components/composite_ported_objects/#arbitrary-nesting","title":"Arbitrary nesting","text":"<p>Composite ported objects can have other composite ported objects as children. This allows for arbitrarily complex nested structures to be built, which can reflect system hierarchies. </p>"},{"location":"components/composite_ported_objects/#automatic-port-creation","title":"Automatic port creation","text":"<p>Currently, ports are not automatically created in <code>CompositePortedObject</code> instances. A common source of errors is either a child not being added to an object, or not manually creating a port. </p> <p>A future update may support automatic port creation when wires with external ports are specified, along with easing the process of forwarding inputs into children.</p>"},{"location":"components/functional_ported_objects/","title":"Defining functions","text":"<p>Functions in <code>psymple</code> are captured by functional ported objects. A system of multivariate functions of the form </p> \\[ \\underline{y} = \\underline{f}(t, \\underline{d}) \\] <p>is captured by a functional ported object with a set of parameter assignments modelling \\(y_i = f_i(t,\\underline{d}_i)\\) for each \\(i\\), where \\(\\underline{d}_i \\subseteq \\underline{d}\\).</p>"},{"location":"components/functional_ported_objects/#example","title":"Example","text":"<p>Example: gravitational attraction</p> <p>The magnitude \\(F\\) of the gravitational attraction force between two bodies with spherically-symmetric densities is given by</p> \\[ F = G \\frac{m_1 m_2}{r^2} \\] <p>where \\(G\\) is the gravitational constant, \\(m_1\\) and \\(m_2\\) are the masses of the two bodies, and \\(r\\) is the scalar distance between their centres of mass.</p> <p>In <code>psymple</code>, this equation can be captured as follows.</p> gravitational force as a FunctionalPortedObject<pre><code>from psymple.build import FunctionalPortedObject\n\nf_gravity = FunctionalPortedObject(\n    name=\"f_gravity\", # (1)!\n    input_ports=[\"G\", \"m_1\", \"m_2\", \"r\"],\n    assignments=[(\"F\", \"G*m_1*m_2 / (r**2)\")],\n)\n</code></pre> <ol> <li><code>name</code> is used to identify the ports of a system, so should be descriptive and unique.</li> </ol> <p>There are multiple syntaxes for specifying assignments. The following are all equivalent in this example:</p> tuple inputdictionary input<code>ParameterAssignment</code> input <pre><code>assignments = [\n    (\"F\", \"G*m_1*m_2 / (r**2)\"), \n]\n</code></pre> <pre><code>assignments = [\n    dict(parameter=\"F\", expression=\"G*m_1*m_2 / (r**2)\"),\n]\n</code></pre> <pre><code>from psymple.build.assignments import ParameterAssignment\n\nassignments = [\n    ParameterAssignment(symbol=\"F\", expression=\"G*m_1*m_2 / (r**2)\"),\n]\n</code></pre> <p>When <code>psymple</code> builds the <code>f_gravity</code> functional ported object, it:</p> <ol> <li>Builds a <code>ParameterAssignment</code> instance for each piece of data in the list <code>assignments</code>. In this case it builds the parameter assignment <code>ParameterAssignment(symbol=\"F\", expression=\"G*m_1*m_2 / (r**2)\")</code>,</li> <li>Creates the parameter symbol <code>F</code>,</li> <li>Creates the set of free symbols <code>G</code>, <code>m_1</code>, <code>m_2</code> and <code>r</code>.</li> </ol> <p>Next, it creates input ports as specified by the user. In this case, it matches each element of the specified input ports <code>[\"G\",\"m_1\",\"m_2\",\"r\"]</code> to its respective free symbol. It then creates output ports for each assignment: in this case a single output port for the parameter symbol <code>F</code>, which can be used to expose the expression <code>\"G*m_1*m_2 / (r**2)\"</code>.</p>"},{"location":"components/functional_ported_objects/#next-steps","title":"Next steps","text":"<p>Once functional ported objects are defined, they can be used to define composite models, or define a simulable system</p>"},{"location":"components/functional_ported_objects/#notes-on-best-practice","title":"Notes on best practice","text":""},{"location":"components/functional_ported_objects/#automatic-port-creation","title":"Automatic port creation","text":"<p>Functional ported objects are able to automatically create input ports. As in the example, <code>psymple</code> collects the free symbols from all symbols on the right-hand side of assignments. If the argument <code>input_ports</code> is not provided, then every free symbol is exposed as an input port.</p> <p>Therefore in the example above, it is equivalent to call:</p> gravitational force as a FunctionalPortedObject<pre><code>from psymple.build import FunctionalPortedObject\n\nf_gravity = FunctionalPortedObject(\n    name=\"f_gravity\",\n    assignments=[(\"F\", \"G*m_1*m_2 / (r**2)\")],\n)\n</code></pre> <p>The automatic creation of input ports can be overridden: see the documentation of <code>FunctionalPortedObject</code> for full details.</p>"},{"location":"components/functional_ported_objects/#when-to-specify-ports","title":"When to specify ports","text":"<p>In practice, the only reason to specify an input port is in the case where a port is to be given a default value, when this should be specified in the <code>input_ports</code> argument. In the above example, the gravitational constant \\(G = 6.67 \\times 10^{-11}\\) might be assigned. This can still be overridden later in model construction or at simulation. This can be done as follows:</p> gravitational force as a FunctionalPortedObject with default values<pre><code>from psymple.build import FunctionalPortedObject\n\nf_gravity = FunctionalPortedObject(\n    name=\"f_gravity\",\n    input_ports=[(\"G\", 6.67e-11)],\n    assignments=[(\"F\", \"G*m_1*m_2 / (r**2)\")],\n)\n</code></pre> <p>System parameters</p> <p>It is also possible to assign meaning to the symbol <code>G</code> itself without having to define it through an input port. See defining a system.</p> <p>There are multiple syntaxes for specifying default values at input ports. The following are all equivalent:</p> tuple inputdictionary input<code>InputPort</code> input <pre><code>input_ports = [(\"G\", 6.67e-11)]\n</code></pre> <pre><code>input_ports = [\n    dict(name=\"G\", default_value=6.67e-11),\n]\n</code></pre> <pre><code>from psymple.build import InputPort\n\ninput_ports = [\n    InputPort(name=\"G\", default_value=6.67e-11),\n]\n</code></pre>"},{"location":"components/variable_ported_objects/","title":"Defining ODEs","text":"<p>Differential equations in <code>psymple</code> are captured by variable ported objects. A system of differential equations of the form </p> \\[  \\frac{d \\underline{x}}{dt} = \\underline{f}(\\underline{x}, t, \\underline{b}) \\] <p>is captured by a variable ported object with a set of differential assignments modelling \\(\\frac{dx_i}{dt} = f_i (\\underline{x}, t, \\underline{b}_i)\\) for each \\(i\\), where \\(\\underline{b}_i \\subseteq \\underline{b}\\). </p>"},{"location":"components/variable_ported_objects/#example","title":"Example","text":"<p>Example: predator-prey system</p> <p>A two-species predator prey system has the form</p> \\[ \\begin{align} \\frac{dx}{dt} &amp;= \\alpha x - \\beta xy \\\\ \\frac{dy}{dt} &amp;= \\gamma xy - \\delta y \\end{align} \\] <p>where:</p> <ul> <li>\\(\\alpha&gt;0\\) is the birth rate of prey population \\(x\\), </li> <li>\\(\\delta&gt;0\\) is the death rate of predator population \\(y\\), </li> <li>\\(\\beta&gt;0\\) is the predation rate of \\(y\\) on \\(x\\), </li> <li>\\(\\gamma&gt;0\\) is the response rate of \\(y\\) from the predation on \\(x\\).</li> </ul> <p>In <code>psymple</code>, this system can be captured as follows.</p> predator-prey as a VariablePortedObject<pre><code>from psymple.build import VariablePortedObject\n\npred_prey = VariablePortedObject(\n    name=\"pred_prey\", # (1)!\n    input_ports=[\"a\",\"b\",\"c\",\"d\"],\n    variable_ports=[\"x\",\"y\"], # (2)!\n    assignments=[(\"x\", \"a*x - b*x*y\"), (\"y\", \"c*x*y - d*y\")],\n)\n</code></pre> <ol> <li> <p><code>name</code> is used to identify the ports of a system, so should be descriptive and unique.</p> </li> <li> <p>Specifying variable ports does not create variables: the variables are created as the left-hand side of the assignments. Variable ports allow the variables created in assignments to be read or updated by other system components.</p> </li> </ol> <p>There are multiple syntaxes for specifying assignments. The following are all equivalent in this example:</p> tuple inputdictionary input<code>DifferentialAssignment</code> input <pre><code>assignments = [\n    (\"x\", \"a*x - b*x*y\"), \n    (\"y\", \"c*x*y - d*y\"),\n]\n</code></pre> <pre><code>assignments = [\n    dict(variable=\"x\", expression=\"a*x - b*x*y\"),\n    dict(variable=\"y\", expression=\"c_x_y - d*y\"),\n]\n</code></pre> <pre><code>from psymple.build.assignments import DifferentialAssignment\n\nassignments = [\n    DifferentialAssignment(symbol=\"x\", expression=\"a*x - b*x*y\"),\n    DifferentialAssignment(symbol=\"x\", expression=\"c_x_y - d*y\"),\n]\n</code></pre> <p>When <code>psymple</code> builds the <code>pred_prey</code> variable ported object, it:</p> <ol> <li>Builds a <code>DifferentialAssignment</code> instance for each piece of data in the list <code>assignments</code>. In this case it builds the differential assignments <code>DifferentialAssignment(symbol=\"x\", expression=\"a*x - b*x*y\")</code> and <code>DifferentialAssignment(symbol=\"y\", expression=\"c*x*y - d*y\")</code>,</li> <li>Creates variable symbols <code>x</code> and <code>y</code>,</li> <li>Creates the set of free symbols <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>.</li> </ol> <p>Next, it creates input ports and variable ports as specified by the user. In this case, it matches each element of the specified input ports <code>[\"a\",\"b\",\"c\",\"d\"]</code> to its respective free symbol. Similarly, it matches elements of the specified variable ports <code>[\"x\",\"y\"]</code> to their respective variable symbols, so that the expressions <code>\"a*x - b*x*y\"</code> and <code>\"c*x*y - d*y\"</code>, respectively, can later be exposed.</p>"},{"location":"components/variable_ported_objects/#next-steps","title":"Next steps","text":"<p>Once variable ported objects are defined, they can be used to define composite models, or define a simulable system</p>"},{"location":"components/variable_ported_objects/#notes-on-best-practice","title":"Notes on best practice","text":""},{"location":"components/variable_ported_objects/#automatic-port-creation","title":"Automatic port creation","text":"<p>Variable ported objects are able to automatically create both input ports and variable ports. As per the example, <code>psymple</code> collects the variable symbols from the left-hand side of any assignment, and the free symbols from all symbols on the right-hand side of assignments which are not variable symbols. If the argument <code>input_ports</code> is not provided, then every free symbol is exposed as an input port. Similarly, if the argument <code>variable_ports</code> is not provided, then every variable symbol is exposed as a variable port.</p> <p>Therefore in the example above, it is equivalent to call:</p> predator-prey as a VariablePortedObject<pre><code>from psymple.build import VariablePortedObject\n\npred_prey = VariablePortedObject(\n    name=\"pred_prey\",\n    assignments=[(\"x\", \"a*x - b*x*y\"), (\"y\", \"c*x*y - d*y\")],\n)\n</code></pre> <p>The automatic creation of input ports can be overridden: see the documentation of <code>VariablePortedObject</code> for full details.</p>"},{"location":"components/variable_ported_objects/#when-to-specify-ports","title":"When to specify ports","text":"<p>In practice, there are only two reasons to specify ports:</p> <ol> <li> <p>In the case where not every variable needs to be exposed. This is useful when, for example, a second-order differential equation is being modelled by a system of first-order equations. For example, the pendulum equation \\(\\ddot y = - \\frac{g}{l} sin(y)\\) can be written as the two first-order equations \\(\\dot y = x\\) and \\(\\dot x = - \\frac{g}{l} sin(y)\\). In this case, we only need to expose the variable <code>y</code>. This can be done as follows:</p> second-order ODE model<pre><code>from psymple.build import VariablePortedObject\n\node = VariablePortedObject(\n    name=\"second_order_ode\",\n    variable_ports=[\"y\"],\n    assignments=[(\"y\", \"x\"), (\"x\", \"-g/l * sin(y)\")],\n)\n</code></pre> </li> <li> <p>In the case where a port is to be given a default value, this should be specified in the <code>input_ports</code> argument. In the above example of the pendulum equation, a default value of \\(g = 9.81\\) might be assigned. This can still be overridden later in model construction or at simulation. This can be done as follows:</p> second-order ODE model with default value<pre><code>from psymple.build import VariablePortedObject\n\node = VariablePortedObject(\n    name=\"second_order_ode\",\n    input_ports=[(\"g\", 9.81)],\n    variable_ports=[\"y\"],\n    assignments=[(\"y\", \"x\"), (\"x\", \"-g/l * sin(y)\")],\n)\n</code></pre> </li> </ol> <p>There are multiple syntaxes for specifying default values at input ports. The following are all equivalent:</p> tuple inputdictionary input<code>InputPort</code> input <pre><code>input_ports = [(\"g\", 9.81)]\n</code></pre> <pre><code>input_ports = [\n    dict(name=\"g\", default_value=9.81),\n]\n</code></pre> <pre><code>from psymple.build import InputPort\n\ninput_ports = [\n    InputPort(name=\"g\", default_value=9.81),\n]\n</code></pre>"},{"location":"development/citing_psymple/","title":"Citing <code>psymple</code>","text":"<p><code>psymple</code> has been peer-reviewed and published by the Journal of Open Source Software (JOSS). </p> <p>The following link will take you to the article page on JOSS where you can also access the software paper, which provides more information on the background, development and context of <code>psymple</code>. </p> <p></p>"},{"location":"development/citing_psymple/#citation-format","title":"Citation format","text":"<p>To cite <code>psymple</code>, please reference the JOSS article. Use the table below to select the format for your citation. </p> APABibTeX <pre><code>Simmons, G., Stern, D., Osang, G., Ponti, L., Gutierrez, A. P., Facciol\u00e0, C., &amp; Hosgood, T. (2025). Psymple: A Python package for complex systems modelling. Journal of Open Source Software, 10(109), 7364. https://doi.org/10.21105/joss.07364\n</code></pre> <pre><code>@article{Simmons_Psymple_A_Python_2025,\n    author = {Simmons, George and Stern, David and Osang, Georg and Ponti, Luigi and Gutierrez, Andrew Paul and Facciol\u00e0, Chiara and Hosgood, Timothy},\n    doi = {10.21105/joss.07364},\n    journal = {Journal of Open Source Software},\n    month = may,\n    number = {109},\n    pages = {7364},\n    title = {{Psymple: A Python package for complex systems modelling}},\n    url = {https://joss.theoj.org/papers/10.21105/joss.07364},\n    volume = {10},\n    year = {2025}\n}\n</code></pre>"},{"location":"development/citing_psymple/#authors","title":"Authors","text":"<p>You can find out more about the article's authors and contributions on the Development Team page.</p> <p>Development Team</p>"},{"location":"development/community_guidelines/","title":"Community Guidelines","text":""},{"location":"development/community_guidelines/#contributing-to-psymple","title":"Contributing to <code>psymple</code>","text":"<p>There are many ways you can be involved in contributing to the development and maintenance of <code>psymple</code>. </p> <ul> <li>Use the issues page to get help with issues, errors, or submit bug reports.</li> <li>Help to edit and maintain the documentation using issues or pull requests.</li> <li>Develop new features, examples, documentation or bug fixes by creating pull requests.</li> <li>Get involved by helping to review open issues and pull requests.</li> <li>Report something you've done using <code>psymple</code>, discuss any big ideas, or simply let us know what you think using our discussion board.</li> </ul> <p>Credit where it is due</p> <p>Anyone who makes consistent and positive contributions, either directly or indirectly, will be offered an entry on our Development Team page.</p>"},{"location":"development/community_guidelines/#automated-testing","title":"Automated testing","text":"<p><code>psymple</code> includes automated testing of its features. More information on how to view tests, run tests, or contribute new tests can be found on the testing <code>psymple</code> page.</p>"},{"location":"development/community_guidelines/#code-of-conduct","title":"Code of conduct","text":"<p><code>psymple</code> is an open-source project which we aim to turn into a community-driven modelling platform. We welcome anyone from all backgrounds and expertise levels to get involved with <code>psymple</code> to create a diverse, welcoming and productive space. We expect anyone contributing to our community to help us do this by following the following simple guidelines:</p> <ol> <li>Open by default. As an open-source and open-access project, we also implement an open-by-default approach to questions, issues, discussions and contributions to promote productivity, efficiency and accuracy.</li> <li>Collaborative by nature. The best solutions are found by engaging with those outside of your usual circles and comfort zone. We ask that you both listen to, and engage with, people with different backgrounds or views to your own to come up with the best outcomes.</li> <li>Think big and small. This project has big ambitions to create impact for as many people as possible, but this requires both an eye for detail for components that make up this project. We ask that every change or addition to the codebase is done with both an eye for excellence and with a holistic view of the whole.</li> <li>Respect for all. People will all levels of experience and knowledge use this project. Treat everyone with respect, empathy and sympathy, and assume that everyone has good intentions. Do not shy away from being critical, but back up everything with evidence, and never make it personal.</li> </ol> <p>We will never tolerate:</p> <ul> <li>Violent threats or language directed against another person.</li> <li>Sexist, racist, or otherwise discriminatory jokes, insults, material and language.</li> <li>Posting (or threatening to post) other people\u2019s personally identifying information (\u201cdoxing\u201d).</li> <li>Sharing private content, such as emails sent privately or non-publicly, or unlogged forums, such as IRC channel history, without the sender\u2019s consent.</li> <li>Excessive profanity. In the context of modelling, there may be examples dealing with profane or sensitive content. This is never a reason to use associated language out of context. Never use swear words.</li> <li>Repeated harassment of others. For the avoidance of doubt, if someone asks you to stop, then stop.</li> <li>Advocating for, or encouraging, any of the above behaviour.</li> </ul>"},{"location":"development/development/","title":"Development","text":"<p><code>psymple</code> is an open-source and open-access project which welcomes all contributions from all third parties. </p>"},{"location":"development/development/#getting-support-or-contributing-to-psymple","title":"Getting support or contributing to <code>psymple</code>","text":"<p>More information about how to contribute to <code>psymple</code> or getting help from the community can be found on the Community Guidelines page. All contributions must adhere to the current Code of Conduct.</p> <p>Read the Code of Conduct</p>"},{"location":"development/development/#governance-and-steering","title":"Governance and steering","text":"<p>The package <code>psymple</code> is currently being produced under a collaboration between CASAS Global and IDEMS International.  Members of both organisations form the current core governance and steering team. In addition to being involved in the day-to-day community of <code>psymple</code>, this team maintains a collective responsibility for the development, maintenance and direction of <code>psymple</code> and are able to:</p> <ul> <li>Make decisions about the overall scope, vision and direction of the project.</li> <li>Make decisions about strategic collaborations with other organizations or individuals.</li> <li>Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests.</li> <li>Update policy documents such as this one.</li> <li>Make decisions when regular community discussion doesn\u2019t produce consensus on an issue in a reasonable time frame.</li> </ul> <p>Follow the link below to find out more about this team and their contributions an expertise.  </p> <p>Core Governance Team</p>"},{"location":"development/development_team/","title":"Development team","text":"<p><code>psymple</code> has been developed using a broad range of expertise and contributions. This page recognises all consistent and positive contributions, both directly to the codebase and indirectly to the scope, direction and suitability of the package. </p>"},{"location":"development/development_team/#core-governance-and-steering-team","title":"Core governance and steering team","text":"<p>This is the current team who maintain a collective responsibility for the development, maintenance and direction of <code>psymple</code>, in alphabetical order of surname.</p> Name Organisation(s) Contribution(s) Years active Chiara Facciol\u00e0 Mathematical Scientist, IDEMS International <ul><li>Applied mathematical modelling</li><li>Examples of complex systems modelling</li></ul> 2024 + Andrew Gutierrez <ul><li>Professor Emeritus of Ecosystem Science, UC Berkeley</li><li>CEO, CASAS Global</li></ul> Biological and ecosystem modelling 2023 + Tim Hosgood Research Scientist (Affiliate), Topos Institute Applied category theory and collaborative modelling 2025 + Georg Osang Postdoctoral Impact Activation Fellow, IDEMS International Code developer and maintainer 2023 + Luigi Ponti <ul><li>Research scientist, ENEA</li><li>Research fellow, CASAS Global</li></ul> <ul><li>Biological and ecosystem modelling</li><li>Github structures and management</li></ul> 2023 + George Simmons Postdoctoral Impact Activation Fellow, IDEMS International <ul><li>Code developer and maintainer</li><li>Applied category theory and collaborative modelling</li><li>Github structures and management</li></ul> 2023 + David Stern Director, IDEMS International <ul><li>Applied category theory and collaborative modelling</li><li>Scalability and impact</li></ul> 2023 +"},{"location":"development/development_team/#development-and-maintenance-team","title":"Development and maintenance team","text":"<p>Info</p> <p>Anyone who contributes consistently and positively to <code>psymple</code> will be offered a place here: see our Community Guidelines for more information.</p> <ul> <li>George Simmons - Code developer and maintainer</li> <li>Georg Osang - Code developer and maintainer</li> <li>Luigi Ponti - Github structures and management</li> <li>Chiara Facciol\u00e0 - Examples and proofreading</li> </ul>"},{"location":"development/testing_psymple/","title":"Testing <code>psymple</code>","text":"<p><code>psymple</code> contains a suite of tests which are automatically run through GitHub.</p>"},{"location":"development/testing_psymple/#current-tests","title":"Current tests","text":"<p>The link below will take you to the current directory of tests, which are stored in the <code>/tests</code> directory.</p> <p>Current tests</p>"},{"location":"development/testing_psymple/#manually-running-tests","title":"Manually running tests","text":"<p>The best way to run the tests is either through an IDE such as VSCode, or in the command line using the <code>tox</code> package, as follows.</p>"},{"location":"development/testing_psymple/#requirements","title":"Requirements","text":"<p>Running Python version <code>3.10</code> or higher.</p>"},{"location":"development/testing_psymple/#running-tests","title":"Running tests","text":"<p>The following commands install <code>tox</code>, setup a test suite, and run the tests.</p>"},{"location":"development/testing_psymple/#install-tox","title":"Install <code>tox</code>","text":"<pre><code>pip install tox\n</code></pre>"},{"location":"development/testing_psymple/#setting-up-the-test-suite","title":"Setting up the test suite","text":"<pre><code>tox -vv --notest\n</code></pre>"},{"location":"development/testing_psymple/#running-the-tests","title":"Running the tests","text":"<pre><code>tox --skip-pkg-install\n</code></pre>"},{"location":"development/testing_psymple/#writing-new-tests","title":"Writing new tests","text":"<p>If you would like to contribute a new test, or you have found a feature which is not tested, then feel free to either create an issue or pull request. All test files must be contained in the <code>/tests</code> directory and have a name of the form <code>test_*.py</code>.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains examples which go through the process of defining, parametrising and simulation systems in <code>psymple</code>. </p> <p>It is recommended to go through these examples after covering, or with reference to, the material in the user guide, which has a bigger focus on the syntax and best practices of using <code>psymple</code>. Some of the examples covered in the user guide are covered here, and vice-versa. </p> <p>These examples are arranged roughly in order of difficulty and complexity, with the later examples also providing less commentary on the implementation.</p> <ul> <li> <p> Population dynamics</p> <p>Population dynamics models, including exponential growth, the logistic equation, and predator-prey models.</p> <p> Get started</p> </li> <li> <p> Mixing problems</p> <p>Mixing of solutions in a single tank or across any number of tanks.</p> <p> Get started</p> </li> <li> <p> Second-order systems</p> <p>How to simulate complex second-order or higher-order systems.</p> <p> Get started</p> </li> </ul>"},{"location":"examples/mixing_problems/","title":"Mixing problems","text":"<p>These examples show how to model mixing problems in <code>psymple</code>. A mixing problem seeks to understand the evolution of a quantity of solvent in a solute, for example a chemical being mixed in a tank of water. These problems can be highly varied, for example solution can enter a tank at variable concentration or rate, or leave the tank at variable rate. Alternatively, several tanks can be connected together, with their solutions being pumped into each other.</p> <p>These examples first consider the problem for a single tank, and then the problem for many arbitrarily linked tanks. </p> <p>In all examples, the core assumption is that tanks are well-mixed, that is, the concentration of the solute is the same throughout the tank at any moment in time.</p> <ul> <li> <p> Single tank</p> <p>Modelling concentrations in a single tank.</p> <p> Get started</p> </li> <li> <p> Multiple tanks</p> <p>Modelling concentrations in multiple tanks with arbitrary links.</p> <p> Get started</p> </li> </ul>"},{"location":"examples/mixing_problems/multiple_tanks/","title":"Multiple tanks mixing problem","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>The previous example modelled a mixing problem with a single tank, which had an external flow in and an external flow out. This example considers a mixing problem consisting of two or more tanks, each of which can have external flows in and out, and which furthermore can have flows to and from other tanks in the system.</p>"},{"location":"examples/mixing_problems/multiple_tanks/#system-data","title":"System data","text":"<p>It will help to first specify the system data. The following data specifies a system of \\(2\\) tanks which are fully interconnected, and each have external flows both in and out. This data can be freely altered to reflect different configurations and all the code in this example will automatically run.</p> system data<pre><code># Number of tanks\nn = 2\n\n# List of tanks created\ntanks_id = [i for i in range(1, n + 1)]\n\n# List of pipes between tanks eg. (1,2) is a pipe from tank 1 to tank 2\nlink_pipes_id = [\n    (i, j) \n    for i in tanks_id \n    for j in tanks_id \n    if j != i\n]\n\n# List of tanks with an external pipe in\npipes_in_id = [1, 2]\n\n# List of tanks with an external pipe out\npipes_out_id = [1, 2]\n</code></pre>"},{"location":"examples/mixing_problems/multiple_tanks/#defining-the-flow-components","title":"Defining the flow components","text":"<p>As for the single tank example, a tank is defined as the aggregation of multiple variables representing inflows and outflows. The following lists of pipes in and out are created in exactly the same way for the single tank example, with pipes in for every tank in <code>pipes_in_id</code> and pipes out for every tank in <code>pipes_out_id</code>.</p> external pipes<pre><code>from psymple.build import VariablePortedObject\n\npipes_in = [\n    VariablePortedObject(\n        name=f\"in_{i}\",\n        assignments=[\n            (\"Q_in\", \"rate * conc\"),\n            (\"V_in\", \"rate\"),\n        ],\n    )\n    for i in pipes_in_id\n]\n\npipes_out = [\n    VariablePortedObject(\n        name=f\"out_{i}\",\n        assignments=[\n            (\"Q_out\", \"-rate * Q_out / V_out\"), \n            (\"V_out\", \"-rate\")\n        ],\n    )\n    for i in pipes_out_id\n]\n</code></pre> <p>To connect two tanks, a connector pipe is required. These have four variables:</p> <ul> <li><code>Q_in</code>, the amount of salt entering the pipe from a tank,</li> <li><code>Q_out</code>, the amount of salt flowing into the next tank. Note that this has the same concentration     as for <code>Q_in</code>,</li> <li><code>V_in</code>, the volume of water entering the pipe from the tank,</li> <li><code>V_out</code>, the volume of water exiting the pipe into the next tank.</li> </ul> <p>A connector pipe is defined for every pair in <code>link_pipes_id</code>.</p> connector pipes<pre><code>connectors = [\n    VariablePortedObject(\n        name=f\"pipe_{i}_{j}\",\n        assignments=[\n            (\"Q_in\", \"- rate * Q_in / V_in\"),\n            (\"Q_out\", \"rate * Q_in / V_in\"),\n            (\"V_in\", \"-rate\"),\n            (\"V_out\", \"rate\"),\n        ],\n    )\n    for i, j in link_pipes_id\n]\n</code></pre>"},{"location":"examples/mixing_problems/multiple_tanks/#defining-the-system","title":"Defining the system","text":"<p>The system is defined by variables <code>Q_1</code>,...,<code>Q_n</code> and <code>V_1</code>,...,<code>V_n</code> representing the mass and volume in each of the \\(n\\) tanks. This is done in an analogous way to the single tank example, where the only thing which becomes more complicated is the aggregation of the variables. Each tank <code>i</code>, and therefore each variable <code>Q_i</code> (and <code>V_i</code>), can have:</p> <ul> <li>External in-flows if <code>i in pipes_in_id</code>,</li> <li>External out-flows if <code>i in pipes_out_id</code>,</li> <li>A flow to tank <code>j</code> for every <code>j</code> such that <code>(i,j) in link_pipes_id</code>,</li> <li>A flow from tank <code>j</code> for every <code>j</code> such that <code>(j,i) in link_pipes_id</code>.</li> </ul> <p>The variable_wires data simply aggregates all these variables to <code>Q_i</code> (and <code>V_i</code>).</p> tanks model<pre><code>from psymple.build import CompositePortedObject\n\ntanks = CompositePortedObject(\n    name=\"tanks\",\n    children=pipes_in + pipes_out + connectors,\n    variable_ports=[f\"Q_{i}\" for i in tanks_id]\n    + [f\"V_{i}\" for i in tanks_id],\n    input_ports=[f\"rate_{i}_{j}\" for i, j in link_pipes_id]\n    + [f\"conc_in_{i}\" for i in pipes_in_id]\n    + [f\"rate_in_{i}\" for i in pipes_in_id]\n    + [f\"rate_out_{i}\" for i in pipes_out_id],\n    directed_wires=[\n        (f\"rate_{i}_{j}\", f\"pipe_{i}_{j}.rate\")\n        for i, j in link_pipes_id\n    ]\n    + [(f\"conc_in_{i}\", f\"in_{i}.conc\") for i in pipes_in_id]\n    + [(f\"rate_out_{i}\", f\"out_{i}.rate\") for i in pipes_out_id]\n    + [(f\"rate_in_{i}\", f\"in_{i}.rate\") for i in pipes_in_id],\n    variable_wires=[\n        (\n            ([f\"in_{i}.Q_in\"] if i in pipes_in_id else [])\n            + ([f\"out_{i}.Q_out\"] if i in pipes_out_id else [])            \n            + [f\"pipe_{j}_{i}.Q_out\" for j in tanks_id if j != i]\n            + [f\"pipe_{i}_{j}.Q_in\" for j in tanks_id if j != i],\n            f\"Q_{i}\",\n        )\n        for i in tanks_id\n    ]\n    + [\n        (\n            ([f\"in_{i}.V_in\"] if i in pipes_in_id else [])\n            + ([f\"out_{i}.V_out\"] if i in pipes_out_id else [])\n            + [f\"pipe_{j}_{i}.V_out\" for j in tanks_id if j != i]\n            + [f\"pipe_{i}_{j}.V_in\" for j in tanks_id if j != i],\n            f\"V_{i}\",\n        )\n        for i in tanks_id\n    ],\n)\n</code></pre> <p>And that's it!</p>"},{"location":"examples/mixing_problems/multiple_tanks/#simulating-the-system","title":"Simulating the system","text":"<p>The following code sets up a simulation in which for \\(t&lt;50\\)&gt;, there are flows of \\(10\\text{l/s}\\) (from tank 2) and \\(4 \\text{l/s}\\) (external) into tank 1 and flows of \\(3\\text{l/s}\\) (to tank 2) and \\(11\\text{l/s}\\) (external) out. Similarly, tank 2 has flows in of \\(3\\text{l/s}\\) (from tank 1) and \\(7\\text{l/s}\\) (external) and flows out of \\(10\\text{l/s}\\) (to tank 1).</p> <p>The external concentration of the fluid entering tank 1 is \\(0.5\\text{g/l}\\) and for tank 2 only pure water is added. </p> <p>The total amount of solution in each tank will remain constant for \\(t&lt;50\\). At \\(t=50\\) the external supply to tank 1 is turned off so that the volume of tank 1 will start to drain.</p> <pre><code>S = System(tanks)\nS.compile()\n\nS.set_parameters(\n    {\n        \"rate_1_2\": 3,\n        \"rate_2_1\": 10,\n        \"rate_in_1\": \"Piecewise((4, T&lt;50), (0, True))\",\n        \"rate_in_2\": 7,\n        \"conc_in_1\": 0.5,\n        \"conc_in_2\": 0,\n        \"rate_out_1\": 11,\n        \"rate_out_2\": 0,\n    }\n)\n\nprint(S)\n\nsym = S.create_simulation(\n    initial_values={\"Q_1\": 20, \"Q_2\": 80, \"V_1\": 800, \"V_2\": 1000}\n)\n\nsym.simulate(t_end=250)\n\nsym.plot_solution()\n</code></pre> <p>The following plot shows the result of the simulation until tank 1 is empty after \\(250\\text{s}\\). </p> <p></p> <p>The figure shows that the concentrations in the two tanks decreasing after \\(t=50\\) since only fresh water is added to the system after this point.</p>"},{"location":"examples/mixing_problems/single_tank/","title":"Single tank mixing problem","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>Consider a single tank with an initial volume of water \\(V_0\\,\\mathrm{l}\\) and an initial amount of \\(M_0\\,\\mathrm{g}\\) of salt dissolved in it. A solution with concentration \\(c(t)\\,\\mathrm{g}/\\mathrm{l}\\) of salt flows into the tank at rate \\(r_0(t)\\,\\mathrm{l}/\\mathrm{s}\\) and the mixed solution flows out of the tank at a rate of \\(r_1(t)\\,\\mathrm{l}/\\mathrm{s}\\).</p> <p>Let \\(V(t)\\) be the volume of solution in the tank at time \\(t\\). Then  \\(V'(t) = r_0(t) - r_1(t)\\). Furthermore, let \\(M(t)\\) be the amount of salt in the solution at time \\(t\\). The rate of change of salt in the solution is given by \\(M'(t) = r_0(t) c(t) - r_1(t) M(t)/V(t)\\).</p>"},{"location":"examples/mixing_problems/single_tank/#modelling-flows-in-psymple","title":"Modelling flows in <code>psymple</code>","text":"<p>In <code>psymple</code>, the variables \\(V(t)\\) and \\(M(t)\\) can be modelled by directly implementing the two differential equations above. In that case, however, would become rigid, meaning that a new situation with more than one in-flow or out-flow would require a new model. Instead, consider what is happening at each point a pipe meets the tank. </p> <p>For the in-flow pipe, there are fluxes \\(V'(t) = r_0(t)\\) and \\(M'(t) = r_0 (t) c(t)\\). Similarly for the outflow pipe, \\(V'(t) = -r_1(t)\\) and \\(M'(t) = - r_1(t) M(t)/V(t)\\).</p> <p>Zero volume error</p> <p>When the tank volume approaches zero, the concentration, and therefore the differential equation controlling mass, can become unpredictable. There are different options as a modeller to deal with cases like this. Here, the decision is taken to keep at least a volume \\(V_m &gt; 0\\) in the tank by turning off the outflow when \\(V \\leqslant V_m\\). In this case, the differential equation in the outflow pipe becomes</p> \\[ V'(t) = \\begin{cases} -r_1(t) &amp; \\text{if $V&gt;V_m$,}\\\\ 0 &amp; \\text{otherwise}. \\end{cases} \\] <p>This situation is initially modelled with two <code>VariablePortedObject</code> instances. </p> <pre><code>from psymple.build import VariablePortedObject\n</code></pre> <p>First, the model for the in pipe is:</p> tank in-flow model<pre><code>pipe_in = VariablePortedObject(\n    name=\"pipe_in\",\n    assignments=[\n        (\"V\", \"r_0\"),\n        (\"M\", \"r_0*c\"),\n    ],\n)\n</code></pre> <p>and the model for the out pipe is:</p> tank out-flow model<pre><code>pipe_out = VariablePortedObject(\n    name=\"pipe_out\",\n    assignments=[\n        (\"V\", \"Piecewise((-r_1, V&gt;V_m), (0, True))\"), # (1)!\n        (\"M\", \"-r_1 * M/V\"),\n    ]\n)\n</code></pre> <ol> <li>The <code>Piecewise</code> function is the implementation in <code>sympy</code> of taking cases. The syntax consists of a list of pairs of the form <code>(value, condition)</code> dealt with in order.</li> </ol>"},{"location":"examples/mixing_problems/single_tank/#defining-the-system-model","title":"Defining the system model","text":"<p>Using a <code>CompositePortedObject</code>, the variables of the in-flow and out-flow objects can be aggregated together. The resulting object can be viewed as the tank itself, with in-flow and out-flow variables for both mass and volume. Additionally, the parameters <code>r_0</code>, <code>r_1</code>, <code>c</code> and <code>V_m</code> are exposed and connected to the internal flow models.</p> single tank model<pre><code>from psymple.build import CompositePortedObject\n\ntank = CompositePortedObject(\n    name=\"tank\",\n    children=[pipe_in, pipe_out],\n    input_ports=[\"r_0\", \"r_1\", \"c\", \"V_m\"],\n    variable_ports=[\"V\", \"M\"],\n    variable_wires=[\n        ([\"pipe_in.V\", \"pipe_out.V\"], \"V\"),\n        ([\"pipe_in.M\", \"pipe_out.M\"], \"M\"),\n    ],\n    directed_wires=[\n        (\"r_0\", \"pipe_in.r_0\"),\n        (\"r_1\", \"pipe_out.r_1\"),\n        (\"c\", \"pipe_in.c\"),\n        (\"V_m\", \"pipe_out.V_m\"),\n    ]\n)\n</code></pre>"},{"location":"examples/mixing_problems/single_tank/#simulating-the-model","title":"Simulating the model","text":"<p>That's it! To simulate the model, define and compile a <code>System</code> class for <code>tank</code>.</p> tank system<pre><code>from psymple.build import System\n\nsystem = System(tank) # (1)!\nsystem.compile()\n</code></pre> <ol> <li>It is also possible to call <code>System(tank, compile=True)</code>. In this case, the command <code>system.compile()</code> doesn't need to be called.</li> </ol> <p>Before simulation, the following must be provided:</p> <ul> <li>Initial values for the variables mass <code>\"V\"</code> and salt amount <code>\"M\"</code>. These are provided using a dictionary passed to the argument <code>initial_values</code> when a simulation is created. </li> <li>Values for the flow rates and concentration in. This is either done using the method <code>system.set_parameters</code>, or as is done here, by passing a dictionary to the argument <code>input_parameters</code> when creating a simulation, allowing multiple scenarios to be considered. </li> </ul>"},{"location":"examples/mixing_problems/single_tank/#constructing-multiple-simulations","title":"Constructing multiple simulations","text":"<p>Four simulations will be constructed. For each, initial values of \\(V_0 = 1000\\) and \\(M_0 = 20\\) are specified. The input parameters for each simulation will be:</p> <ol> <li>\\(r_0 = 4 = r_1\\) and \\(c = 0.5\\). In this case, the volume of the tank should stay constant,     and the amount of salt should continually increase towards a limit.</li> <li>\\(r_0 = 2\\), \\(r_1 = 4\\) and \\(c = 0.5\\). In this case, the volume of the tank will decrease.</li> <li>For a more creative scenario, set \\(r_0 = 4sin(t) + 4\\) and \\(r_1 = 4\\), \\(c = 0.5\\). The     volume of the tank will fluctuate, but stay centred around \\(1000\\).</li> <li>Finally, try \\(r_0 = 4 = r_1\\) and \\(c = 0.5sin(t) + 0.5\\). </li> </ol> <p>In all cases, \\(V_m=10\\) is specified.</p> Setting up the simulations<pre><code>for name, inputs in zip(\n    [\"sim_1\", \"sim_2\", \"sim_3\", \"sim_4\"], # (1)!\n    [\n        {\"r_0\": 4, \"r_1\": 4, \"c\": 0.5, \"V_m\": 10}, # (2)!\n        {\"r_0\": 2, \"r_1\": 4, \"c\": 0.5, \"V_m\": 10},\n        {\"r_0\": \"4*sin(T) + 4\", \"r_1\": 4, \"c\": 0.5, \"V_m\": 10},\n        {\"r_0\": 4, \"r_1\": 4, \"c\": \"0.5*sin(T) + 0.5\", \"V_m\": 10},\n    ]\n):\n    sim = system.create_simulation(\n        name=name, \n        initial_values={\"V\": 1000, \"M\": 20}, # (3)!\n        input_parameters=inputs,\n    )\n    sim.simulate(t_end=1000)\n</code></pre> <ol> <li>These are the names for each simulation.</li> <li>For each simulation, the set of input parameters is passed as a dictionary.</li> <li>The initial values for each simulation are defined here. They can also be varied in the same way as the input parameters are varied.</li> </ol>"},{"location":"examples/mixing_problems/single_tank/#visualising-the-outputs","title":"Visualising the outputs","text":"<p>Finally, a plot of each model run can be produced by using the <code>plot_solution</code> method. Each simulation can be accessed from the dictionary <code>system.simulations</code> using the keys <code>\"sim_1\"</code>, <code>\"sim_2\"</code>, <code>\"sim_3\"</code> or <code>\"sim_4\"</code>. The following code produces plots of both the mass and volume for the first simulation.</p> plotting solutions<pre><code>system.simulations[\"sim_1\"].plot_solution({\"M\"})\nsystem.simulations[\"sim_1\"].plot_solution({\"V\"})\n</code></pre> <p>The outputs are shown below.</p> Mass plotVolume plot <p></p> <p></p> <p>As expected, the mass of salt in the tank increases towards a limit of \\(500 \\text{g}\\), while the volume stays constant.</p>"},{"location":"examples/population_dynamics/","title":"Population modelling","text":"<p>Population modelling is a tool for analysing complex systems in epidemiology, agriculture, ecology and beyond. Models driven by differential equations are able to help in predicting the behaviour of these systems, which may exhibit complex interactions, feedback loops, and sensitivity to initial conditions. </p> <p>This set of tutorials covers basic examples on how to use <code>psymple</code> to model populations and interactions between them. They are arranged roughly in order of complexity, with some examples following on from previous ones. Earlier examples often contain more comments on the implementation choices than later ones.</p> <ul> <li> <p> Malthusian growth</p> <p>The most basic model for a population undergoing exponential growth.</p> <p> Get started</p> </li> <li> <p> Logistic growth</p> <p>A model which limits the exponential growth of Malthusian populations.</p> <p> Get started</p> </li> <li> <p> Predator-prey dynamics</p> <p>A model which captures the two-way interactions between two species.</p> <p> Get started</p> </li> </ul>"},{"location":"examples/population_dynamics/logistic_growth/","title":"The logistic equation","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>This example follows on from Malthusian growth. The code for a simple Malthusian population produced there is available in the drop-down box below.</p> Malthusian population <pre><code>from psymple.build import VariablePortedObject\n\npop = VariablePortedObject(\n    name=\"malthusian_pop\",\n    assignments=[(\"x\", \"r*x\")],\n    input_ports=[(\"r\", 0.1)],\n)\n</code></pre> <p>The logistic equation is a simple population model which prevents populations from growing exponentially by introducing a density-dependent mortality term. The differential equation is given by </p> \\[  \\frac{dx}{dt} = rx - \\frac{r}{K} x^2 = rx \\left( 1-\\frac{x}{K} \\right) \\] <p>where \\( r \\) is the per-capita growth rate and \\( K \\) is known as the carrying capacity. </p>"},{"location":"examples/population_dynamics/logistic_growth/#a-direct-implementation","title":"A direct implementation","text":"<p>The logistic equation can be simply captured by modifying the assignment of the Malthusian population <code>pop</code>, as follows.</p> <pre><code>from psymple.build import VariablePortedObject\n\nlogistic_simple = VariablePortedObject(\n    name=\"logistic_simple\",\n    assignments=[(\"x\", \"r*x*(1-x/K)\")],\n    input_ports=[(\"r\", 0.1), (\"K\", 10)],\n)\n</code></pre> <p>This is a perfectly valid implementation. The power of <code>psymple</code> appears, however, when the implementation reflects the structure of the model.</p>"},{"location":"examples/population_dynamics/logistic_growth/#a-structural-implementation","title":"A structural implementation","text":"<p>The right-hand side of the logistic equation is structurally the sum of two rates: the Malthusian component \\( rx \\), and the limiting component \\( \\frac{r}{K} x^2 \\). The process of variable aggregation ties these two components together to produce a model whose structure reflects the structure of the differential equation. </p> <p>Since the Malthusian component has already been defined using the object <code>pop</code>, it remains to define the limiting component. This can be done as follows.</p> <pre><code>limit = VariablePortedObject(\n    name=\"limit\",\n    assignments=[(\"x\", \"- r/K* x**2\")],\n    input_ports=[(\"r\", 0.1), (\"K\", 10)],\n)\n</code></pre> <p>The logistic model is formed in a composite ported object containing both the Malthusian and logistic limit components. A variable wire connecting their variables with a variable port <code>x</code> of the composite object tells <code>psymple</code> to aggregate the two objects together.</p> <pre><code>from psymple.build import CompositePortedObject\n\nlogistic_pop = CompositePortedObject(\n    name=\"logistic_pop\",\n    children=[pop, limit],\n    variable_ports = [\"x\"],\n    variable_wires=[([\"malthusian_pop.x\", \"limit.x\"], \"x\")],\n)\n</code></pre>"},{"location":"examples/population_dynamics/logistic_growth/#sharing-input-parameters","title":"Sharing input parameters","text":"<p>To complete the logistic model, the interface of <code>logistic_pop</code> can be made the same as the simple implementation <code>logistic_simple</code> by specifying input ports for both <code>r</code> and <code>K</code>. Directed wires tell <code>psymple</code> to forward these values into the corresponding values in <code>malthusian_pop</code> and <code>limit</code>. In the case of the parameter <code>r</code>, the wire can be given multiple destinations to tell <code>psymple</code> to identify the <code>r</code> inputs of <code>malthusian_pop</code> and <code>limit</code> together.</p> <pre><code>from psymple.build import CompositePortedObject\n\nlogistic_pop = CompositePortedObject(\n    name=\"logistic_pop\",\n    children=[pop, limit],\n    input_ports=[(\"r\", 0.1), (\"K\", 10)],\n    directed_wires=[\n        (\"r\", [\"malthusian_pop.r\", \"limit.r\"]), # (1)!\n        (\"K\", \"limit.K\"),\n    ],\n    variable_ports = [\"x\"],\n    variable_wires=[([\"malthusian_pop.x\", \"limit.x\"], \"x\")],\n)\n</code></pre> <ol> <li>Multiple destinations can be specified for a single wire by using a list.</li> </ol>"},{"location":"examples/population_dynamics/logistic_growth/#running-the-simulation","title":"Running the simulation","text":"<p>The final thing to do is set up and run the simulation. As a bonus, it's good to check that the simulation produced by <code>logistic_pop</code> is identical to that produced to <code>logistic_simple</code>, to demonstrate the variable aggregation in action.</p> <pre><code>from psymple.build import System\n\nsystem_1 = System(logistic_simple)\nsystem_1.compile()\n\nsim_1 = system_1.create_simulation(initial_values={\"x\": 1})\nsim_1.simulate(t_end=100)\nsim_1.plot_solution()\n\n\nsystem_2 = System(logistic_pop)\nsystem_2.compile()\n\nsim_2 = system_2.create_simulation(initial_values={\"x\": 1})\nsim_2.simulate(t_end=100)\nsim_2.plot_solution()\n</code></pre> <p>Running the code produces the same simulation, as expected, which is shown here. </p> <p></p> <p>The simulation initially shows the population numbers increasing exponentially, before the mortality term takes over and the numbers tend towards their maximum value of \\( 10 \\), which is the same value as the parameter \\( K \\). This motivates the naming of \\( K \\) as the carrying capacity.</p>"},{"location":"examples/population_dynamics/malthusian_population/","title":"Malthusian growth","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>A fundamental equation in population dynamics describes a population which reproduces as a constant rate \\(r\\). Without any other influence, this population grows exponentially according to the differential equation \\( \\frac{dx}{dt} = rx \\). This phenomenon is known as Malthusian growth.</p> <p>This example covers:</p> <ul> <li>How to build a Malthusian growth model in <code>psymple</code>,</li> <li>How to adjust the model to have different inputs depending on the data available,</li> <li>How to build reusable model interfaces.</li> </ul>"},{"location":"examples/population_dynamics/malthusian_population/#implementation-in-psymple","title":"Implementation in <code>psymple</code>","text":""},{"location":"examples/population_dynamics/malthusian_population/#building-a-the-differential-equation","title":"Building a the differential equation","text":"<p>The differential equation \\( \\frac{dx}{dt} = rx \\) is captured in a <code>VariablePortedObject</code> instance as follows.</p> <pre><code>from psymple.build import VariablePortedObject\n\npop = VariablePortedObject(\n    name=\"malthusian_pop\",\n    assignments=[(\"x\", \"r*x\")],\n    input_ports=[(\"r\", 0.1)],\n)\n</code></pre> <p>See defining ODEs for more information about this syntax. Specifying The value of parameter 'r' at an input port has two advantages:</p> <ol> <li>The variable ported object <code>pop</code> becomes a general, reusable object,</li> <li>The default value can be overwritten from elsewhere in a larger system.</li> </ol>"},{"location":"examples/population_dynamics/malthusian_population/#creating-and-running-a-simulation","title":"Creating and running a simulation","text":"<p>The following commands create, run and plot a simulation of our equation with initial condition \\( x = 1 \\). </p> <pre><code>from psymple.build import System\n\nsystem_1 = System(pop)\nsystem_1.compile()\n\nsim_1 = system_1.create_simulation(initial_values={\"x\": 1})\nsim_1.simulate(t_end=25)\nsim_1.plot_solution()\n</code></pre> <p></p>"},{"location":"examples/population_dynamics/malthusian_population/#changing-parameters-at-simulation","title":"Changing parameters at simulation","text":"<p>The input parameter \\( r \\), which was given a default value of \\( 0.1 \\) can be overwritten at simulation. The following code creates a second simulation <code>sim_2</code> with \\( r = 0.2 \\). </p> <pre><code>from psymple.build import System\n\nsystem_1 = System(pop)\nsystem_1.compile()\n\nsim_2 = system_1.create_simulation(\n    initial_values={\"x\": 1}, \n    input_parameters={\"r\": 0.2}\n)\nsim_2.simulate(t_end=25)\nsim_2.plot_solution()\n</code></pre> <p></p>"},{"location":"examples/population_dynamics/malthusian_population/#overriding-default-behaviour-with-a-function","title":"Overriding default behaviour with a function","text":"<p>Suppose that the birth rate \\( b \\) and death rate \\( d \\) of a population are known, with values \\( 0.4 \\) and  \\( 0.2 \\), respectively. This is equivalent to a Malthusian population with rate \\( r = b - d \\). Instead of changing the model <code>pop</code> to accept inputs <code>b</code> and <code>d</code>, the calculation for \\( r \\) can be performed using a <code>FunctionalPortedObject</code>, and then pass this value to the input of <code>pop</code>. </p> <p>Another benefit of this approach is to create a model which directly aligns with the data available, rather than requiring any pre-procession of birth and death rates into a single growth rate.</p>"},{"location":"examples/population_dynamics/malthusian_population/#defining-the-rate-function","title":"Defining the rate function","text":"<p>The following code captures the calculation of the rate function in the object <code>rate</code>.</p> <pre><code>from psymple.build import FunctionalPortedObject\n\nrate = FunctionalPortedObject(\n    name=\"rate\",\n    assignments=[(\"r\", \"b-d\")],\n)\n</code></pre> <p>See defining functions for more information about this syntax. As opposed to <code>pop</code>, the inputs <code>b</code> and <code>d</code> have not been given default values, but their ports have still been created automatically. Values will be provided to these ports later in the example.</p>"},{"location":"examples/population_dynamics/malthusian_population/#linking-the-rate-function-to-the-differential-equation-model","title":"Linking the rate function to the differential equation model","text":"<p>Next, the variable object 'pop' needs to read its value of 'r' from the value of 'r' produced by the function 'rate'. To do this, first import both <code>pop</code> and <code>rate</code> as children of a <code>CompositePortedObject</code>. Inside this object, defining a directed wire from 'rate.r' to 'malthusian_pop.r' tells <code>psymple</code> to identify these two values. See defining composite models for more information about adding children and wires to composite objects.</p> <pre><code>from psymple.build import CompositePortedObject\n\npop_system = CompositePortedObject(\n    name=\"malthusian_pop_system\",\n    children=[pop, rate],\n    directed_wires=[(\"rate.r\", \"malthusian_pop.r\")],\n)\n</code></pre> <p>Notice that the variable object 'pop' never had to be redefined. Since it was defined generally, its mechanics can be reused over and over again. The following commands simulate and plot this new system.</p>"},{"location":"examples/population_dynamics/malthusian_population/#exposing-inputs-in-a-composite-system","title":"Exposing inputs in a composite system","text":"<p>The object <code>pop_system</code> cannot be simulated until values for <code>b</code> and <code>d</code> are provided to <code>rate</code>. There are three ways this can be done: </p> <ol> <li>By updating the definition of <code>rate</code> to include default values for <code>b</code> and <code>d</code>,</li> <li>By giving default values to <code>b</code> and <code>d</code> at the object <code>pop_system</code> and telling <code>psymple</code> to pass these values to <code>rate</code>,</li> <li>By specifying values of <code>b</code> and <code>d</code> at simulation, and telling <code>psymple</code> to pass the values to <code>rate</code>. </li> </ol> <p>To accomplish either (2) or (3), input ports for <code>b</code> and <code>d</code> in the object <code>pop_system</code> need to be created, and directed wires defined from these to <code>rate.b</code> and <code>rate.d</code>, respectively. The difference between (2) and (3) is whether default values are specified for these new input ports. The following code updates the definition of <code>pop_system</code> to demonstrate method (2). </p> <pre><code>pop_system = CompositePortedObject(\n    name=\"malthusian_pop_system\",\n    children=[pop, rate],\n    input_ports=[(\"b\", 0.4), (\"d\", 0.2)],\n    directed_wires=[\n        (\"rate.r\", \"malthusian_pop.r\"),\n        (\"b\", \"rate.b\"),\n        (\"d\", \"rate.d\")\n    ],\n)\n</code></pre>"},{"location":"examples/population_dynamics/malthusian_population/#simulating-the-composite-system","title":"Simulating the composite system","text":"<p>The following creates a new system <code>system_2</code> for simulating <code>pop_system</code>. Notice that the initial value \\( x = 1 \\) must be specified by addressing <code>malthusian_pop.x</code>. The next section covers how to create an interface to address the initial value simply by <code>x</code>. </p> <p>With default values \\( b = 0.4 \\) and \\( d = 0.2 \\), the simulation should produce Malthusian growth with rate \\( r = 0.4 - 0.2 = 0.2 \\). The plot confirms this by producing the same plot obtained in the section changing parameters at simulation.</p> <pre><code>system_2 = System(pop_system)\nsystem_2.compile()\n\nsim_3 = system_2.create_simulation(initial_values={\"malthusian_pop.x\": 1})\nsim_3.simulate(t_end=25)\nsim_3.plot_solution()\n</code></pre> <p></p>"},{"location":"examples/population_dynamics/malthusian_population/#creating-an-interface","title":"Creating an interface","text":"<p>An interface for a ported object simply refers to the ports which it defines. In a composite ported object, input, output and variable ports can all be defined to expose internal information. </p> <p>When modelling in <code>psymple</code>, it is important to consider the interfaces of different components to maximise compatibility and reusability. For example, in population dynamics, it could make sense to decide that every model of a single population has a set of rates as inputs, and exposes a single variable. </p> <p>The model <code>pop</code> for Malthusian growth does this, exposing an input rate <code>r</code> and a variable <code>x</code>. The composite model <code>pop_system</code> for birth-death dynamics, however, only exposes its input rates <code>b</code> and <code>d</code>, and not a variable. Adding a variable to the interface of <code>pop_system</code> standardises these two models and makes them function similarly, hiding the additional complexity inside <code>pop_system</code>. Another way to view this is by giving the composite ported object <code>pop_system</code> the same type of interface as a variable ported object.</p> <p>The following code adjusts the composite object <code>pop_system</code> by giving it a variable port <code>x</code>, and telling <code>psymple</code> to aggregate the values of <code>malthusian_pop.x</code> and <code>x</code> by defining a variable wire.</p> <pre><code>pop_system = CompositePortedObject(\n    name=\"malthusian_pop_system\",\n    children=[pop, rate],\n    input_ports=[(\"b\", 0.4), (\"d\", 0.2)],\n    directed_wires=[\n        (\"rate.r\", \"malthusian_pop.r\"),\n        (\"b\", \"rate.b\"),\n        (\"d\", \"rate.d\")\n    ],\n    variable_ports=[\"x\"],\n    variable_wires=[([\"malthusian_pop.x\"], \"x\")],\n)\n</code></pre>"},{"location":"examples/population_dynamics/predator_prey/","title":"Predator-prey systems","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>A predator-prey system was introduced in the defining ODEs tutorial. This example shows how to build this system on top of the single-species population models constructed in Malthusian growth and logistic growth.</p>"},{"location":"examples/population_dynamics/predator_prey/#lotka-volterra-model","title":"Lotka-Volterra model","text":"<p>This example begins with the simplest predator-prey system: the Lotka-Volterra system of differential equations for a prey species \\(x\\) and predator \\(y\\).</p> \\[ \\begin{align} \\frac{dx}{dt} &amp;= a x - b xy \\\\ \\frac{dy}{dt} &amp;= c xy - d y \\end{align} \\] <p>where:</p> <ul> <li>\\(a&gt;0\\) is the birth rate of prey population \\(x\\), </li> <li>\\(d&gt;0\\) is the death rate of predator population \\(y\\), </li> <li>\\(b&gt;0\\) is the predation rate of \\(y\\) on \\(x\\), </li> <li>\\(c&gt;0\\) is the response rate of \\(y\\) from the predation on \\(x\\).</li> </ul> <p>In this example, this system will be modelled with three components: </p> <ol> <li>the prey equation \\(\\frac{dx}{dt} = ax\\), </li> <li>the predator equation \\(\\frac{dy}{dt} = -dy\\), </li> <li>the interaction system \\(\\frac{dx}{dt} = -bxy, \\frac{dy}{dt} = cxy\\).</li> </ol>"},{"location":"examples/population_dynamics/predator_prey/#single-population-components","title":"Single population components","text":"<p>The models for the prey and predator are the simple exponential growth components constructed in the Malthusian growth example.</p> <pre><code>from psymple.build import VariablePortedObject\n\nprey = VariablePortedObject(\n    name=\"prey\",\n    assignments=[(\"x\", \"r*x\")],\n    input_ports=[(\"r\", 0.4)],\n)\n\npred = VariablePortedObject(\n    name=\"pred\",\n    assignments=[(\"x\", \"r*x\")],\n    input_ports=[(\"r\", -0.2)],\n)\n</code></pre>"},{"location":"examples/population_dynamics/predator_prey/#interaction-component","title":"Interaction component","text":"<p>The interaction component is also modelled using a <code>VariablePortedObject</code> instance.</p> <pre><code>interaction = VariablePortedObject(\n    name=\"pred-prey\",\n    assignments=[(\"x\", \"r_1*x*y\"), (\"y\", \"r_2*x*y\")],\n    input_ports=[(\"r_1\", -0.2), (\"r_2\", 0.1)],\n)\n</code></pre>"},{"location":"examples/population_dynamics/predator_prey/#the-system-model-and-simulation","title":"The system model and simulation","text":"<p>The system is formed by the three components above, with the prey and predator variables defined by aggregating variables across the individual species model and the interaction model.</p> <pre><code>from psymple.build import CompositePortedObject\n\necosystem = CompositePortedObject(\n    name=\"ecosystem\",\n    children=[pred, prey, interaction],\n    variable_ports=[\"x\", \"y\"],\n    variable_wires=[\n        ([\"prey.x\", \"pred-prey.x\"], \"x\"),\n        ([\"pred.x\", \"pred-prey.y\"], \"y\"),\n    ]\n)\n</code></pre> <p>The following code builds and runs a simulation with initial values \\(x(0)=10\\) and \\(y(0)=2\\). </p> <pre><code>from psymple.build import System\n\nsystem = System(ecosystem, compile=True)\n\nsim = system.create_simulation(initial_values={\"x\": 10, \"y\": 2})\nsim.simulate(t_end=100)\nsim.plot_solution()\n</code></pre> <p>The simulation gives the following plot, showing the oscillations characteristic of a two-species Lotka-Volterra model.</p> <p></p>"},{"location":"examples/population_dynamics/predator_prey/#logistic-prey-model","title":"Logistic prey model","text":"<p>While the previous example exhibited stable oscillations, it is a common modelling choice to introduce a carrying capacity to populations to prevent exponential growth. The individual model of the prey species can be replaced with the one developed in the logistic growth example.</p> <pre><code>pop = VariablePortedObject(\n    name=\"pop\",\n    assignments=[(\"x\", \"r*x\")],\n)\n\nlimit = VariablePortedObject(\n    name=\"limit\",\n    assignments=[(\"x\", \"- r/K* x**2\")],\n)\n\nprey = CompositePortedObject(\n    name=\"prey\",\n    children=[pop, limit],\n    input_ports=[(\"r\", 0.4), (\"K\", 10)],\n    directed_wires=[\n        (\"r\", [\"pop.r\", \"limit.r\"]), \n        (\"K\", \"limit.K\"),\n    ],\n    variable_ports = [\"x\"],\n    variable_wires=[([\"pop.x\", \"limit.x\"], \"x\")],\n)\n</code></pre> <p>Since this model has the same interface as the previous Malthusian growth model for <code>prey</code>, the composite model <code>ecosystem</code> and the simulation can be run exactly as before. Here is the simulation output.</p> <p></p> <p>The simulation still exhibits oscillations, but this time decaying in magnitude as the system approaches the steady state of \\(x=2\\), \\(y=\\frac{8}{5}\\). See the drop-down box below for this calculation.</p> Steady state calculation <p>The system constructed above is of the form </p> \\[ \\begin{align} \\frac{dx}{dt} &amp;= ax \\left( 1-\\frac{x}{K} \\right) - bxy \\\\ \\frac{dy}{dt} &amp;= cxy - dy \\end{align} \\] <p>A steady state of the system occurs when both derivatives are zero. There are three cases:</p> <ul> <li>if \\(x=0\\), then either equation implies \\(y=0\\),</li> <li>if \\(y=0\\), then the first equation gives \\(ax \\left( 1-\\frac{x}{K} \\right) = 0\\), or equivalently \\(x = K\\) (the solution \\(x=0\\) is the above case),</li> <li> <p>if both \\(x \\ne 0\\) and \\(y \\ne 0\\), the second equation gives \\(x=\\frac{d}{c}\\) and the first equation gives </p> \\[ y = \\frac{a}{b} \\left( 1-\\frac{x}{K} \\right) = \\frac{a}{b} \\left( 1-\\frac{a}{bK} \\right). \\] <p>Substituting \\(a=0.4, b=0.2, c=0.1, d=0.2\\) and \\(K=10\\) gives the steady state \\(x=2\\) and \\(y=2 \\times \\frac{4}{5} = \\frac{8}{5}\\).</p> </li> </ul>"},{"location":"examples/population_dynamics/predator_prey/#tritrophic-systems","title":"Tritrophic systems","text":"<p>Almost all ecosystems in nature are tritrophic, meaning there are at least three different types of consumer in the food chain. For example, the chain can consist of a plant which produces energy from sunlight and soil nutrients, a herbivore which eats the vegetative matter of the plant for its growth, and a carnivore which predates on the herbivore. The interactions between these trophic levels create the fine balance in an ecosystem, but are difficult to study and model. </p> <p>In <code>psymple</code>, a tritrophic model can be built out of components in the same way as the predator-prey models already considered, which are bitrophic in nature. This example constructs the following system of equations:</p> \\[ \\begin{align} \\frac{dx}{dt} &amp;= ax \\left( 1-\\frac{x}{K} \\right) - bxy \\\\ \\frac{dy}{dt} &amp;= cxy - dy - eyz \\\\ \\frac{dz}{dt} &amp;= fyz - gz \\end{align} \\]"},{"location":"examples/population_dynamics/predator_prey/#individual-species-models","title":"Individual species models","text":"<p>The prey \\(x\\) is given the logistic species model <code>prey</code> constructed above. The middle predator \\(y\\) and the apex predator \\(z\\) are both given exponential decay models:</p> <pre><code>pred_mid = VariablePortedObject(\n    name=\"pred_mid\",\n    assignments=[(\"x\", \"r*x\")],\n    input_ports=[(\"r\", -0.8)],\n)\n\npred_apex = VariablePortedObject(\n    name=\"pred_apex\",\n    assignments=[(\"x\", \"r*x\")],\n    input_ports=[(\"r\", -0.05)],\n)\n</code></pre>"},{"location":"examples/population_dynamics/predator_prey/#interactions","title":"Interactions","text":"<p>There are two interactions in the system, one between the prey and the intermediate predator, and the second between the intermediate and apex predators. These are defined as follows:</p> <pre><code>int_prey_mid = VariablePortedObject(\n    name=\"int_prey_mid\",\n    assignments=[(\"x\", \"r_1*x*y\"), (\"y\", \"r_2*x*y\")],\n    input_ports=[(\"r_1\", -0.4), (\"r_2\", 0.3)],\n)\n\nint_mid_apex = VariablePortedObject(\n    name=\"int_mid_apex\",\n    assignments=[(\"x\", \"r_1*x*y\"), (\"y\", \"r_2*x*y\")],\n    input_ports=[(\"r_1\", -0.2), (\"r_2\", 0.1)],\n)\n</code></pre>"},{"location":"examples/population_dynamics/predator_prey/#ecosystem-and-simulation","title":"Ecosystem and simulation","text":"<p>The ecosystem is then constructed using a series of variable aggregations.</p> <pre><code>ecosystem = CompositePortedObject(\n    name=\"ecosystem\",\n    children=[prey, pred_mid, pred_apex, int_prey_mid, int_mid_apex],\n    variable_ports=[\"x\", \"y\", \"z\"],\n    variable_wires=[\n        ([\"prey.x\", \"int_prey_mid.x\"], \"x\"),\n        ([\"pred_mid.x\", \"int_prey_mid.y\", \"int_mid_apex.x\"], \"y\"),\n        ([\"pred_apex.x\", \"int_mid_apex.y\"], \"z\")\n    ]\n)\n</code></pre> <p>The simulation is defined and run in the usual way.</p> <pre><code>system = System(ecosystem, compile=True)\n\nsim = system.create_simulation(initial_values={\"x\": 10, \"y\": 5, \"z\": 2})\nsim.simulate(t_end=100)\nsim.plot_solution()\n</code></pre> <p></p> <p>The simulation shows the system oscillating before approaching stable equilibria. For this set of parameters, the middle predator doesn't thrive as well as the apex predator.</p>"},{"location":"examples/second_order_odes/","title":"Second-order ODE systems","text":"<p>Since any second-order (or higher-order) ODE can be written as a system of first-order ODEs, <code>psymple</code> can be used to simulate complex composite differential equation systems of any order.</p> <p>This collection of examples covers dynamics such as projectile motion and motion under gravity, where the position of an object is specified by second-order equations for its acceleration.</p> <ul> <li> <p> Projectile motion</p> <p>The motion of an object acting under multiple forces.</p> <p> Get started</p> </li> <li> <p> The three body problem</p> <p>A classical problem in celestial mechanics. </p> <p> Get started</p> </li> </ul>"},{"location":"examples/second_order_odes/projectile_motion/","title":"Projectile motion","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>The motion of a projectile can be affected by multiple forces. This example considers the motion of an object under gravity, which adds an acceleration vertically downwards, and air resistance which acts against the velocity vector.</p> <p>In general, the force exerted due to air resistance is given by</p> \\[ \\mathbf{F}_D = \\frac{1}{2}C_D \\rho A v \\mathbf{v} \\] <p>where \\(C_D\\) is the drag coefficient, \\(\\rho\\) is the air density, \\(A\\) is the surface area, \\(\\mathbf{v}\\) is the velocity vector and \\(v\\) is its magnitude.</p>"},{"location":"examples/second_order_odes/projectile_motion/#vertical-motion","title":"Vertical motion","text":"<p>The special case where the motion is vertically downwards is built up in the user guide, through composite systems, defining systems and running simulations. For completeness, the final version of that example is repeated here, with an added variable tracking the position of the projectile.</p>"},{"location":"examples/second_order_odes/projectile_motion/#system-functions-and-parameters","title":"System functions and parameters","text":"<p>In <code>psymple</code> functions and parameters can be specified at the system level to speed up implementation. In this case the system defines the acceleration due to gravity, \\(g=\\pu{9.81 m/s^2}\\), ambient air density \\(\\rho = \\pu{1.225 kg/m^3}\\), and the function \\(frac_0\\), defined by \\(frac_0(a,b,d) = \\frac{a}{b}\\) if \\(b \\ne 0\\) and \\(frac_0(a,b,d) = d\\) if \\(b=0\\).</p> <pre><code>frac_0 = lambda a,b,d: a/b if b != 0 else d\n\nfrom psymple.build import System\n\nsystem = System()\nsystem.add_system_parameter(\"g\", \"9.81\"),\nsystem.add_system_parameter(\"rho\", \"1.225\")\nsystem.add_utility_function(name=\"frac_0\", function=frac_0)\n</code></pre>"},{"location":"examples/second_order_odes/projectile_motion/#differential-equation-system","title":"Differential equation system","text":"<p>When the projectile has mass, the equations of motion are given by</p> \\[ \\begin{align} \\frac{dv}{dt} &amp;= g - \\frac{1}{2m}C_D \\rho A v^2 \\\\ \\frac{dx}{dt} &amp;= -v \\end{align} \\] <p>A <code>psymple</code> model for this system is given as follows.</p> <pre><code>from psymple.build import (\n    FunctionalPortedObject, \n    VariablePortedObject,\n    CompositePortedObject,\n)\n\nv_gravity = VariablePortedObject( \n    name=\"v_gravity\",\n    assignments=[(\"v\", \"g\"), (\"x\", \"-v\")], \n)\n\nv_drag = VariablePortedObject(\n    name=\"v_drag\",\n    assignments=[(\"v\", \"-mu * v**2\")],\n)\n\nf_drag = FunctionalPortedObject(\n    name=\"f_drag\",\n    assignments=[(\"mu\", \"frac_0(1/2 * C * rho * A, m, 0)\")], \n)\n\nmodel = CompositePortedObject(\n    name=\"model\",\n    children=[v_gravity, v_drag, f_drag],\n    input_ports=[\"C\", \"A\", \"m\"],\n    variable_ports=[\"v\", \"x\"],\n    directed_wires=[\n        (\"C\", \"f_drag.C\"),\n        (\"A\", \"f_drag.A\"),\n        (\"m\", \"f_drag.m\"),\n        (\"f_drag.mu\", \"v_drag.mu\"), \n    ],\n    variable_wires=[\n        ([\"v_gravity.v\", \"v_drag.v\"], \"v\"),\n        ([\"v_gravity.x\"], \"x\"),\n    ],\n)   \n</code></pre> <p>Only aggregate once</p> <p>Note that the aggregation in the above example only happens across the velocity <code>v</code> and not the position <code>x</code>. In general, consider first-order systems </p> \\[ \\begin{align} \\dot{y}_i &amp;= f_i \\\\ \\dot{x}_i &amp;= y_i \\end{align} \\] <p>implementing the second-order ODE \\(\\ddot{x}_i = f_i\\) for \\(i=1,2\\). If \\(x_1\\) and \\(x_2\\) are aggregated to a variable \\(x\\) with differential equation \\(\\dot{x} = y_1 + y_2\\), then the equation \\(\\ddot{x} = f_1 + f_2\\) would be correct. If additionally, however, \\(y_1\\) and \\(y_2\\) are also aggregated to a variable \\(y\\), then</p> \\[ \\ddot{x} = \\dot{y}_1 + \\dot{y}_2 = (f_1 + f_2) + (f_1 + f_2) = 2(f_1+f_2) \\] <p>that is, the equation is doubled. Therefore one must be careful to only aggregate over either the variables \\(x_i\\) or the variables \\(y_i\\), but not both.</p>"},{"location":"examples/second_order_odes/projectile_motion/#simulation","title":"Simulation","text":"<p>To build a simulation, the composite object <code>model</code> needs to be added to the existing <code>system</code> instance. A simulation is then created and run in the usual way.</p> <pre><code>system.set_object(model)\n\nsim = system.create_simulation(\n    initial_values = {\"v\": 0, \"x\": 200}, \n    input_parameters={\"C\": 1.1, \"A\": 0.2, \"m\": 2})\nsim.simulate(t_end=10)\n\nsim.plot_solution()\n</code></pre> <p></p> <p>The simulation shows that the object accelerates from rest to a terminal velocity of ~\\(\\pu{12.067 m/s}\\). This agrees with value given by the standard formula for terminal velocity</p> \\[ v_t = \\sqrt{\\frac{2mg}{\\rho A C_D}} \\] <p>obtained by finding the steady state of the equations of motion, after substituting the simulation values of \\(m=2\\), \\(\\rho=1.225\\), \\(A=0.2\\) and \\(C_D = 1.1\\). </p>"},{"location":"examples/second_order_odes/projectile_motion/#projectile-motion-in-a-plane","title":"Projectile motion in a plane","text":"<p>A more general case allows the projectile to move freely in the \\(x-y\\) plane.</p>"},{"location":"examples/second_order_odes/projectile_motion/#model-setup","title":"Model setup","text":"<p>The model for motion in a plane in almost identical to the vertical special case. One difference is now four variables are required to track the coordinate motion: two for distance and two for velocity. The second difference is that the drag magnitude function must be given the projectile's speed: \\(s = \\sqrt{v_x^2 + v_y^2}\\). This is calculated using a <code>FunctionalPortedObject</code> instance:</p> <pre><code>speed = FunctionalPortedObject(\n    name=\"speed\",\n    assignments=[(\"s\", \"sqrt(v_x**2 + v_y**2)\")]\n)\n</code></pre> <p>Finally, the positive direction is now set as upwards. The full model is given in the drop-down box below.</p> Planar projectile motion <pre><code>motion = VariablePortedObject(\n    name=\"motion\",\n    assignments=[\n        (\"v_x\", \"0\"),\n        (\"v_y\", \"-g\"),\n        (\"pos_x\", \"v_x\"),\n        (\"pos_y\", \"v_y\"),\n    ]\n)\n\ndrag = VariablePortedObject(\n    name=\"drag\",\n    assignments=[\n        (\"v_x\", \"-mu*v_x*s\"),\n        (\"v_y\", \"-mu*v_y*s\"),\n    ]\n)\n\ndrag_magnitude = FunctionalPortedObject(\n    name=\"drag_magnitude\",\n    assignments=[(\"mu\", \"frac_0(1/2*coeff*rho*area,mass,0)\")]\n)\n\nspeed = FunctionalPortedObject(\n    name=\"speed\",\n    assignments=[(\"s\", \"sqrt(v_x**2 + v_y**2)\")]\n)\n\nmodel = CompositePortedObject(\n    name=\"proj\",\n    children=[motion, drag, drag_magnitude, speed],\n    input_ports=[\"C\", \"A\", \"m\"],\n    variable_ports=[\"pos_x\", \"pos_y\", \"vel_x\", \"vel_y\"],\n    directed_wires=[\n        (\"C\", \"drag_magnitude.coeff\"),\n        (\"A\", \"drag_magnitude.area\"),\n        (\"m\", \"drag_magnitude.mass\"),\n        (\"drag_magnitude.mu\", \"drag.mu\"),\n        (\"motion.v_x\", \"speed.v_x\"),\n        (\"motion.v_y\", \"speed.v_y\"),\n        (\"speed.s\", \"drag.s\"),\n    ],\n    variable_wires=[\n        ([\"motion.v_x\", \"drag.v_x\"], \"vel_x\"),\n        ([\"motion.v_y\", \"drag.v_y\"], \"vel_y\"),\n        ([\"motion.pos_x\"], \"pos_x\"),\n        ([\"motion.pos_y\"], \"pos_y\"),\n    ]\n)\n</code></pre>"},{"location":"examples/second_order_odes/projectile_motion/#simulating-and-plotting","title":"Simulating and plotting","text":"<p>The following simulation fires the same projectile as for the vertical case from the same position, except now with a horizontal velocity of \\(\\pu{75 m/s}\\) and vertical velocity of \\(\\pu{15 m/s}\\) (upwards). </p> <pre><code>system.set_object(model)\n\nsim = system.create_simulation(\n    initial_values ={\"pos_x\": 0, \"pos_y\": 200, \"vel_x\": 75, \"vel_y\": 15}, \n    input_parameters={\"C\": 1.1, \"A\": 0.2, \"m\": 2})\nsim.simulate(t_end=10)\nsim.plot_solution()\n</code></pre> <p></p>"},{"location":"examples/second_order_odes/projectile_motion/#producing-other-plots","title":"Producing other plots","text":"<p>The plotting functionality in <code>psymple</code> is currently fairly basic. It is, however, straight-forward to extract simulation time series to produce more custom plots. The following code produces a positional plot of the projectile.</p> <pre><code>import matplotlib.pyplot as plt\n\npos_x = sim.variables[\"pos_x\"].time_series\npos_y = sim.variables[\"pos_y\"].time_series\n\nplt.plot(pos_x, pos_y)\nplt.grid()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/second_order_odes/three_body_problem/","title":"Three body problem","text":"Raw code <p>The raw code for this example without explanations can be found here.</p> <p>The three body problem, or more generally the \\(n\\)-body problem, is a classical problem in celestial mechanics. The statement of the problem is to find the trajectories of three or more massive bodies under the gravitational influence of each other. </p>"},{"location":"examples/second_order_odes/three_body_problem/#system-of-equations","title":"System of equations","text":"<p>The magnitude of the gravitational force acting between two objects of masses \\(m_1\\) and \\(m_2\\) is given by \\(F = \\frac{Gm_1m_2}{r^2}\\), where \\(G = \\pu{6.67 \\times 10^{-11} N m^2/kg}\\) and \\(r\\) is the distance between their centres. </p> <p>For the dynamics of two or more bodies, each body experiences a gravitational force from every other body in the direction of that body with the above magnitude. Therefore for \\(n\\) bodies, the system of differential equations is derived by applying Newton's second law:</p> \\[ \\frac{d^2 \\mathbf{r}_i}{dt^2} = \\sum_{1 \\leqslant i \\ne j \\leqslant n} G m_j \\frac{(\\mathbf{r}_j - \\mathbf{r}_i)}{|\\mathbf{r}_j - \\mathbf{r}_i|^3}, \\qquad i=1,\\dots,n. \\]"},{"location":"examples/second_order_odes/three_body_problem/#setup-in-psymple","title":"Setup in <code>psymple</code>","text":"<p>To model the \\(n\\)-body problem in <code>psymple</code>, for simplicity assume the motion is happening in a plane, so that \\(\\mathbf{r}_i = (x_i, y_i)\\). Then each differential equation above corresponds to a pair of second-order differential equations in \\(x_i\\) and \\(y_i\\). To implement this in <code>psymple</code> requires an additional pair of equations for \\(v_{x_i}\\) and \\(v_{y_i}\\), the components of the velocity \\(\\frac{d \\mathbf{r}_i}{dt}\\). </p> <p>The following implementation models the force components</p> \\[ F_{ij} = \\frac{Gm_j}{((x_j-x_i)^2 + (y_j - y_i)^2)^{\\frac{3}{2}}} \\left(x_j - x_i, y_j-y_i \\right) \\] <p>for \\(i \\ne j\\). The velocity components of body \\(i\\) satisfy the differential equations obtained by aggregating the components of \\(F_{ij}\\) for \\(j=1,\\dots,i-1,i+1,\\dots,n\\). </p>"},{"location":"examples/second_order_odes/three_body_problem/#common-objects","title":"Common objects","text":"<p>The following objects are common calculations for each \\(F_{ij}\\). </p> <pre><code>from psymple.build import VariablePortedObject, FunctionalPortedObject\n\nvars = VariablePortedObject(\n    name=\"vars\",\n    assignments=[\n        (\"v_x\", \"mu * Del_x\"),\n        (\"v_y\", \"mu * Del_y\"),\n    ]\n)\n\ndist = FunctionalPortedObject(\n    name=\"dist\",\n    assignments=[\n        (\"Del_x\", \"x_o - x\"),\n        (\"Del_y\", \"y_o - y\"),\n        (\"d\", \"sqrt((x_o-x)**2 + (y_o-y)**2)\"),\n    ]\n)\n\nforce = FunctionalPortedObject(\n    name=f\"force\",\n    assignments=[(\"mu\", \"G*m/d**3\")]\n)\n</code></pre>"},{"location":"examples/second_order_odes/three_body_problem/#velocity-model","title":"Velocity model","text":"<p>The following class <code>velocity</code> is used to create the model for \\(F_{ij}\\), with the argument <code>id</code> used to identify each pair \\((i,j)\\). </p> <pre><code>from psymple.build import CompositePortedObject \n\nclass velocity(CompositePortedObject):\n\n    def __init__(self, id):\n        super().__init__(\n            name=f\"velocity_{id}\",\n            children=[vars, force, dist],\n            input_ports=[\"x\", \"y\", \"x_o\", \"y_o\", \"m_o\"],\n            variable_ports=[\"v_x\", \"v_y\"],\n            output_ports=[\"v_x\", \"v_y\"],\n            directed_wires=[\n                (\"m_o\", \"force.m\"),\n                (\"x\", \"dist.x\"),\n                (\"y\", \"dist.y\"),\n                (\"x_o\", \"dist.x_o\"),\n                (\"y_o\", \"dist.y_o\"),\n                (\"dist.Del_x\", \"vars.Del_x\"),\n                (\"dist.Del_y\", \"vars.Del_y\"),\n                (\"dist.d\", \"force.d\"),\n                (\"force.mu\", \"vars.mu\"),\n                (\"vars.v_x\", \"v.x\"),\n                (\"vars.v_y\", \"v.y\"),\n            ],\n            variable_wires=[\n                ([\"vars.v_x\"], \"v_x\"),\n                ([\"vars.v_y\"], \"v_y\")\n            ]\n        )\n</code></pre> <p>Wrapping <code>psymple</code> objects in classes</p> <p>Using classes to wrap objects in <code>psymple</code> is a powerful way to maximise reusability of objects, create custom behaviour depending on arguments, or implement custom functions and attributes to simplify model building.</p> <p>Similarly, the following class <code>pos</code> will be used to integrate the velocity variables to calculate the position of each body.</p> <pre><code>class pos(VariablePortedObject):\n    def __init__(self, id):\n        super().__init__(\n            name=f\"pos_{id}\",\n            assignments=[\n                (\"x\", \"v_x\"),\n                (\"y\", \"v_y\"),\n            ]\n        )\n</code></pre>"},{"location":"examples/second_order_odes/three_body_problem/#defining-the-system-with-aggregation","title":"Defining the system with aggregation","text":"<p>First, specify some helpful identifiers for the orbiting bodies and the interactions between them.</p> <pre><code>n=3\n\nbodies = [f\"{i+1}\" for i in range(n)]\nints = [f\"{i+1},{j+1}\" for i in range(n) for j in range(n) if i != j]\n</code></pre> <p>Next, create instances of all the interactions and position integrators that will make up the system components.</p> <pre><code>forces = [velocity(id) for id in ints]\npositions = [pos(id) for id in bodies]\n</code></pre> <p>Finally, define the composite system. This object exposes as inputs the masses of each body, connects these masses to the relevant force components, and connects the velocity variables to the position integrators. Finally, it aggregates the velocity components together and exposes all velocity and position variables.</p> <pre><code>coords = [\"x\", \"y\"]\n\nn_body_model = CompositePortedObject(\n    name=\"system\",\n    children = forces + positions,\n    variable_ports=[\n        port \n        for i in bodies \n        for port in [f\"x_{i}\", f\"y_{i}\", f\"v_x_{i}\", f\"v_y_{i}\"]\n    ],\n    input_ports=[f\"m_{i}\" for i in bodies],\n    directed_wires=[\n        (f\"m_{i}\", [f\"velocity_{j},{i}.m_o\" for j in bodies if j != i])\n        for i in bodies\n    ]\n    + [\n        (\n            f\"pos_{i}.{coord}\", \n            [f\"velocity_{i},{j}.{coord}\" for j in bodies if j != i]\n            + [f\"velocity_{j},{i}.{coord}_o\" for j in bodies if j != i]\n        )\n        for i in bodies for coord in coords\n    ]\n    + [\n        (f\"velocity_{i},{int(i)%n + 1}.v_{coord}\", f\"pos_{i}.v_{coord}\") # (1)!\n        for i in bodies for coord in coords\n    ],\n    variable_wires=[\n        (\n            [f\"velocity_{i},{j}.v_{coord}\" for j in bodies if j != i], \n            f\"v_{coord}_{i}\"\n        )\n        for i in bodies for coord in coords\n    ]\n    + [\n        ([f\"pos_{i}.{coord}\"], f\"{coord}_{i}\")\n        for i in bodies for coord in coords\n    ],\n)\n</code></pre> <ol> <li>The choice <code>int(i)%n + 1</code> ensures only one of the interaction components connects to a position integrator for each \\(i\\). </li> </ol>"},{"location":"examples/second_order_odes/three_body_problem/#simulation-and-plots","title":"Simulation and plots","text":"<p>To run a simulation, a <code>System</code> instance is created for <code>n_body_model</code> which also specifies the system parameter <code>G</code>, the gravitational constant. In this example, matters are scaled so that \\(G = 1\\). </p> <pre><code>S = System(\n    n_body_model,\n    system_parameters=[(\"G\", 1)],\n    compile=True\n)\n</code></pre>"},{"location":"examples/second_order_odes/three_body_problem/#a-choice-of-initial-conditions","title":"A choice of initial conditions","text":"<p>There are many initial conditions and values of masses for each body which create interesting behaviour for a three body problem. Here is just one set.</p> <pre><code>initial_values={\n    \"x_1\": 0.9700436,\n    \"y_1\": -0.24308753,\n    \"x_2\": 0,\n    \"y_2\": 0,\n    \"x_3\": -0.9700436,\n    \"y_3\": 0.24308753,\n    \"v_x_1\": 0.466203685,\n    \"v_y_1\": 0.43236573,\n    \"v_x_2\": -2*0.466203685,\n    \"v_y_2\": -2*0.43236573,\n    \"v_x_3\": 0.466203685,\n    \"v_y_3\": 0.43236573,\n}\n\ninput_parameters={\n    \"m_1\": 1,\n    \"m_2\": 1,\n    \"m_3\": 1,\n}\n</code></pre> <p>Here is the simulation run.</p> <pre><code>sim = S.create_simulation(\n    initial_values=initial_values,\n    input_parameters=input_parameters,\n)\n\nsim.simulate(t_end=10)\n</code></pre>"},{"location":"examples/second_order_odes/three_body_problem/#trajectory-plots","title":"Trajectory plots","text":"<p>Rather than use the command <code>sim.plot_solution()</code> to generate the time series plots, the six position variables can instead be extracted and plotted against each other to generate the trajectory plots for each of the three bodies.</p> <pre><code>import matplotlib.pyplot as plt\n\nx_1 = sim.variables[\"x_1\"].time_series\ny_1 = sim.variables[\"y_1\"].time_series\n\nx_2 = sim.variables[\"x_2\"].time_series\ny_2 = sim.variables[\"y_2\"].time_series\n\nx_3 = sim.variables[\"x_3\"].time_series\ny_3 = sim.variables[\"y_3\"].time_series\n\n\nplt.plot(x_1, y_1, color=\"blue\")\nplt.plot(x_2, y_2, color=\"red\")\nplt.plot(x_3, y_3, color=\"green\")\n\nplt.show()\n</code></pre> <p></p>"},{"location":"mathematics/functional_substitution/","title":"Functional substitution","text":"<p>Functional substitution, along with variable aggregation, are the key components of the composition process in <code>psymple</code>.</p>"},{"location":"mathematics/functional_substitution/#mathematical-basis","title":"Mathematical basis","text":"<p>Functional substitution, also called partial composition, is defined as follows.</p> <p>Definition</p> <p>Given functions \\( f: X^n \\longrightarrow Z \\) and \\( g: Y^m \\longrightarrow X \\), the partial composition of \\( f \\) with \\( g \\) at coordinate \\( i \\) is given by</p> \\[ f \\vert_{x_i = g} = f(x_1, \\dots, x_{i-1}, g(y_1, \\dots, y_m), x_{i+1}, \\dots, x_n): X^{n-1} \\times Y^m \\longrightarrow Z. \\]"},{"location":"mathematics/functional_substitution/#discussion","title":"Discussion","text":"<p>In <code>psymple</code>, a key assumption is that complex models consist of many substituted or partially composed functions. Returning to the example of the drag force exerted on a projectile, where the magnitude \\( F \\) was given by</p> \\[ F = \\frac{1}{2} \\rho C_D A v^2. \\] <p>The air density, for example, \\( \\rho \\) can itself be a function of air pressure \\( P \\) and temperature \\( T \\), and each in turn may be known as functions of spatial geographic coordinates \\( (x,y) \\) and altitutde \\( A \\). Similarly, the effective area \\( A \\) or drag coefficient may be known as a function of geometric parameters \\( r_1, \\dots, r_k \\).</p> <p>Constructing a static model</p> \\[ F = \\frac{1}{2} \\rho(P(x,y,A),T(x,y,A)) C_D(r_1,\\dots,r_k) A(r_1,\\dots,r_k) v^2 \\] <p>including these dependencies is both unclear, since the main components of the force magnitude are lost amongst other functions, and unreusable, since for example the model for air density becomes fixed: changing this model would also require a full reconstruction of the model for \\( F \\) itself.</p>"},{"location":"mathematics/functional_substitution/#implementation-detail","title":"Implementation detail","text":"<p>In <code>psymple</code>, functional substitution is stored formally by connecting the ports of ported object instances by <code>Directedwire</code> instances. A directed wire \\( W_d(P_s, D) \\) from source port \\( P_s \\) to destination ports \\( D = \\{P_1,\\dots,P_k \\} \\) stores the information associated to functional substitution. Concretely, the source port \\( P_s \\) exposes an assignment containing an expression, and the destination ports \\( D \\) expose symbols attached to expressions of other assignments. </p> <p>Therefore the directed wire \\( W_d(P_s, D) \\) represents the functional substitutions</p> \\[ \\{g_1 \\vert_{x_1 = f}, g_2 \\vert_{x_2 = f}, \\dots, g_k \\vert_{x_k = f} \\} \\] <p>where \\( f \\) is the expression exposed at \\( P_s \\), and \\( x_i \\) is the symbol exposed at \\( P_i \\in D \\) in expression \\( g_i \\). </p> <p>On model compilation, the directed wires in a system are interpreted and the function substitutions performed accordingly. </p>"},{"location":"mathematics/ported_objects/","title":"Ported objects","text":"<p>Ported objects are the core components of how <code>psymple</code> functions. </p>"},{"location":"mathematics/ported_objects/#mathematical-basis","title":"Mathematical basis","text":"<p>Abstractly, a ported object is defined as follows.</p> <p>Definition</p> <p>A ported object \\( O = O(I, P) \\) stores information \\(I = \\{ I_1, \\dots, I_m \\} \\), and ports \\( P = \\{P_1, \\dots, P_n \\} \\) with \\( P_i = \\{ I_{i_1}, \\dots, I_{i_{k_i}} \\} \\) such that \\( P_i \\cap P_j = \\emptyset \\) for all \\( i \\ne j \\) and</p> \\[ \\bigcup_{i=1}^n P_i = \\bigcup_{i=1}^n \\{ I_{i_1}, \\dots, I_{i_{k_i}} \\} \\subseteq I. \\] <p>Any \\( I_{i_j} \\in P_i \\) is called exposed information and any \\( I_k \\in I \\setminus (P_1 \\cup \\cdots \\cup P_n) \\) is called internal information. </p>"},{"location":"mathematics/ported_objects/#implementation-detail","title":"Implementation detail","text":"<p>Ported objects in <code>psymple</code> are implemented in three layers.</p>"},{"location":"mathematics/ported_objects/#base-class","title":"Base Class","text":"<p>A base class <code>PortedObject</code> implementing a ported object object \\( O = O(\\emptyset, P) \\), that is a ported object containing no information but abstractly implementing ports. There are three concrete types of port:</p> <ul> <li>Variable ports, implemented as <code>VariablePort</code> instances, which are designed to expose differential equations,</li> <li>Input ports, implemented as <code>InputPort</code> instances, which are designed to expose symbols,</li> <li>Output ports, implemented as <code>OutputPort</code> instances, which are designed to expose functions.</li> </ul>"},{"location":"mathematics/ported_objects/#assignment-containers","title":"Assignment Containers","text":"<p>Ported objects implementing variables and parameters, whose information consists of sets of <code>Assignment</code> instances and <code>sympy.Symbol</code> instances. These are abstractly implemented as <code>PortedObjectWithAssignments</code> instances. Concretely, there are:</p>"},{"location":"mathematics/ported_objects/#variable-ported-objects","title":"Variable ported objects","text":"<p>Implemented as <code>VariablePortedObject</code>.</p> <p>These objects are designed to model systems of differential equations as <code>DifferentialAssignment</code> instances. Together, the differential assignments define the following ported object information:</p> <ul> <li>a set of variable symbols, obtained from the <code>symbol_wrapper</code> attribute of each <code>DifferentialAssignment</code> instance,</li> <li>a set of symbolic rate functions, obtained from the <code>expression_wrapper</code> attribute of each <code>DifferentialAssignment</code> instance,</li> <li>a set of free symbols, defined as the set of all symbols appearing in each symbolic rate function, except those which are variable symbols.</li> </ul> <p>Variable ported objects can be given variable ports, which access the symbolic rate functions associated to a variable, and input ports, which allow free symbols to be defined externally.</p>"},{"location":"mathematics/ported_objects/#functional-ported-objects","title":"Functional ported objects","text":"<p>Implemented as <code>FunctionalPortedObject</code>.</p> <p>These objects are designed to model a collection of multivariate functions as <code>ParameterAssignment</code> instances. Together, the parameter assignments define the following ported object information:</p> <ul> <li>a set of parameter symbols, obtained from the <code>symbol_wrapper</code> attribute of each <code>ParameterAssignment</code> instance,</li> <li>a set of symbolic functions, obtained from the <code>expression_wrapper</code> attribute of each <code>ParameterAssignment</code> instance,</li> <li>a set of free symbols, defined as the set of all symbols appearing in each symbolic rate function.</li> </ul> <p>Note</p> <p>In contrast to variable ported objects, parameter symbols and free symbols must be disjoint. Therefore no symbol appearing on the left-hand side of an assignment can appear on the right-hand side of any assignment. </p> <p>Functional ported objects can be given input ports, which allow the free symbols to be defined externally. Output ports are automatically generated from each assignment, which access the symbolic functions associated to each parameter symbol.</p>"},{"location":"mathematics/ported_objects/#composite-ported-objects","title":"Composite ported objects","text":"<p>Implemented as <code>CompositePortedObject</code>.</p> <p>These objects implement functional substitution and variable aggregation between the functions and differential equations stored in other ported objects contained as children. They can link or expose any information exposed at the ports of any of its children, which means:</p> <ul> <li>any function exposed at an output port of a child</li> <li>any differential equation exposed at the variable port of a child</li> <li>any symbol exposed at the input port of a child</li> </ul> <p>Composite ported objects can be given input ports, output ports and variable ports which, when linked by wires to child ports, expose information in the same way as the corresponding ports of child objects.</p>"},{"location":"mathematics/ported_objects/#using-ported-objects","title":"Using ported objects","text":"<p>More information about the user-facing ported objects can be found on the following pages:</p> <ul> <li>Functional ported objects</li> <li>Variable ported objects</li> <li>Composite ported objects</li> </ul>"},{"location":"mathematics/variable_aggregation/","title":"Variable aggregation","text":"<p>Variable aggregation, along with functional substitution, are the key components of the composition process in <code>psymple</code>.</p>"},{"location":"mathematics/variable_aggregation/#mathematical-basis","title":"Mathematical basis","text":"<p>Variable aggregation is the process of combining two ordinary differential equations linearly, as follows.</p> <p>Definition</p> <p>Let \\( \\frac{dx}{dt} = f(x,y,t,\\underline{a}) \\) and \\( \\frac{dy}{dt} = g(x,y,t,\\underline{b}) \\) be differential equations. Their aggregation under the identification \\( (x,y) \\longrightarrow z \\) is the differential equation</p> \\[ \\frac{dz}{dt} = f(z,z,t,\\underline{a}) + g(z,z,t,\\underline{b}). \\] <p>For example:</p> <p>Example</p> <p>The aggregation of the differential equations \\( \\frac{dx}{dt} = axt +  by + c \\) and \\( \\frac{dy}{dt} = dsin(y) \\) under the identification \\( (x,y) \\longrightarrow z \\) is given by </p> \\[ \\frac{dz}{dt} = (azt + bz + c) + (dsin(z)). \\]"},{"location":"mathematics/variable_aggregation/#discussion","title":"Discussion","text":"<p>In <code>psymple</code>, a key assumption is that complex dynamic systems are constructed by aggregating the differential equations of smaller components. For example, consider a tank of water with \\( n \\) pipes in adding water at rates \\( \\{r_1,\\dots,r_n\\} \\) and \\( m \\) pipes out extracting water at rates \\( \\{s_1,\\dots,s_m \\} \\). Then the rate of change of the volume \\( V \\) of water in the tank is given by</p> \\[ \\frac{dV}{dt} = \\sum_{i=1}^n r_i - \\sum_{i=1}^m s_i. \\] <p>If this equation were implemented statically, then adapting the model to account for, for example, a leak whose flow rate is proportional to \\( V \\), would require writing a completely new differential equation. With the concept of variable aggregation, the contribution equation for \\( V \\) can instead be considered at each entry and exit point of the tank. For each entry pipe, this is</p> \\[ \\frac{dV}{dt} = r_i \\] <p>and at each exit pipe this is</p> \\[ \\frac{dV}{dt} = -s_i. \\] <p>The original tank model is then the aggregation of all of these component equations. If the leak were to be modelled too, by</p> \\[ \\frac{dV}{dt} = -\\alpha V \\] <p>then this can simply be added to the list of variable aggregations to perform.</p>"},{"location":"mathematics/variable_aggregation/#implementation-detail","title":"Implementation detail","text":"<p>In <code>psymple</code>, variable aggregation is stored formally by connecting the ports of ported object instances by <code>VariableAggregationWiring</code> instances. A variable aggregation wire \\( W_v(C, P_d, I) \\) from child ports \\( C = \\{P_1,\\dots,P_k \\} \\) to destination port \\( P_d \\) with identification variable \\( I \\) stores the information associated to variable aggregation. </p> <p>Concretely, the child ports \\( C \\) each expose a differential assignment to be aggregated together, the identification variable \\( I \\) stores the identification to be made, and the destination port \\( P_d \\) exposes the aggregated assignment.</p> <p>On model compilation, the variable aggregation wires in a system are interpreted and the variable aggregations are performed accordingly. </p>"},{"location":"mathematics/variables_parameters/","title":"Variables, parameters and equations","text":""},{"location":"mathematics/variables_parameters/#mathematical-basis","title":"Mathematical basis","text":"<p>The core purpose of <code>psymple</code> is to build simulable dynamic systems from components of functions and differential equations. These components have concrete mathematical definitions:</p> <p>Definition</p> <p>A mathematical variable \\( x \\) is a system state whose time-derivative can be expressed as a function of itself, time, and external dependencies:</p> \\[ \\frac{dx}{dt} = f(x, t, \\underline{b}) \\] <p>Here, external dependency can mean any other system variable, parameter (see below), or constant.</p> <p>Definition</p> <p>A mathematical parameter \\( p \\) is a state whose value can be expressed as a function of time, and external dependencies:</p> \\[ p = f(t, \\underline{b}) \\]"},{"location":"mathematics/variables_parameters/#implementation-detail","title":"Implementation detail","text":"<p>We notice the similarity of these definitions is that they each consist of an object (respectively a derivative or a symbol) on the left-hand side of an equality, and a function on the right-hand side. To store these concepts flexibly, <code>psymple</code> implements the following objects:</p>"},{"location":"mathematics/variables_parameters/#variables","title":"Variables","text":"<p><code>Variable</code> instances store a <code>sympy.Symbol</code> instance which is formally interpreted as a first-order time derivative of that symbol.</p>"},{"location":"mathematics/variables_parameters/#parameters","title":"Parameters","text":"<p><code>Parameter</code> instances store a <code>sympy.Symbol</code> instance.</p>"},{"location":"mathematics/variables_parameters/#expression-wrappers","title":"Expression wrappers","text":"<p><code>ExpressionWrapper</code> instances store a symbolic representation of a function, which can be any object subclassed from the <code>sympy.Basic</code> class.</p>"},{"location":"mathematics/variables_parameters/#differential-assignments","title":"Differential assignments","text":"<p><code>DifferentialAssignment</code> instances store a <code>Variable</code> instance together with an <code>ExpressionWrapper</code> instance to formally represent a differential equation of the form</p> \\[ \\frac{dx}{dt} = f(x, t, \\underline{b}) \\]"},{"location":"mathematics/variables_parameters/#parameter-assignments","title":"Parameter assignments","text":"<p><code>ParameterAssignment</code> instances store a <code>Parameter</code> instance together with an <code>ExpressionWrapper</code> instance to formally represent an equation </p> \\[ p = f(t, \\underline{b}) \\]"},{"location":"mathematics/variables_parameters/#example-usage","title":"Example usage","text":"<p>Warning</p> <p>These objects are abstract objects for formal storage. In normal usage of <code>psymple</code>, none of these classes need to be explicitly instantiated, since there are interfaces to ease their creation. The examples below give a flavour of how <code>psymple</code> works underneath.</p>"},{"location":"mathematics/variables_parameters/#differential-equations","title":"Differential equations","text":"<p>The logistic model is given by</p> \\[ \\frac{dx}{dt} = rx \\left( 1-\\frac{x}{k} \\right) \\] <p>In <code>psymple</code> this equation is captured as follows.</p> Logistic equation as a `DifferentialAssignment`<pre><code>from psymple.build.assignments import DifferentialAssignment\n\nassg_x = DifferentialAssignment(\n    symbol=\"x\", \n    expression=\"r*x*(1-x/k)\",\n)\n</code></pre> <p>The <code>DifferentialAssignment</code> class has attributes <code>symbol_wrapper</code> and <code>expression_wrapper</code> which store created instances of <code>Variable</code> and <code>ExpressionWrapper</code>, respectively. The creation of the <code>sympy.Symbol</code> instance and the parsing of the <code>expression</code> argument into a <code>sympy</code> expression is automatically performed.</p>"},{"location":"mathematics/variables_parameters/#functions","title":"Functions","text":"<p>The magnitude \\( F \\) of the drag force exerted on a projectile travelling through a medium is given by</p> \\[ F = \\frac{1}{2} \\rho C_D A v^2 \\] <p>where \\( \\rho \\) is the medium density, \\( C_D \\) is the drag coefficient, \\( A \\) is the effective surface area and \\( v \\) is the speed of the projectile relative to the medium. In <code>psymple</code>, this is captured as follows.</p> Drag equation as a `ParameterAssignment`<pre><code>from psymple.build.assignments import ParameterAssignment\n\nassg_F = ParameterAssignment(\n    symbol=\"F\",\n    assignment=\"1/2 * rho * C_D * A * v**2\"\n)\n</code></pre> <p>Similar to above, the <code>ParameterAssignment</code> class has attributes <code>symbol_wrapper</code> and <code>expression_wrapper</code> which store created instances of <code>Parameter</code> and <code>ExpressionWrapper</code>, respectively.</p>"},{"location":"overview/introduction/","title":"Introduction","text":"<p>The following pages give an overview of why <code>psymple</code> exists, the problems it tries to address, and how it is designed. An overview of the content presented can be found in the article on <code>psymple</code> at the following link.</p> <p></p>"},{"location":"overview/introduction/#roots-in-ecological-modelling","title":"Roots in ecological modelling","text":"<p><code>psymple</code> was initially designed to deal with complex ecological modelling, where species, or life stages of species, undergo population dynamics, with rates which are often non-trivial composite functions of state variables or time-varying parameters such as environmental, climatic or geographic features.</p> <p>The difficulty in modelling such systems does not necessarily lie in any one component: population dynamics, interactions or rate models are usually well-understood in isolation. The issues arise when trying to piece together all of the functions or differential equations in a system where multiple species exist, with, for examples subsets of them in competition for resources or predating on each other.</p> <p>Read the full statement of need</p>"},{"location":"overview/introduction/#modular-hybrid-modelling","title":"Modular hybrid modelling","text":"<p><code>psymple</code> deals with this problem by allowing each component, be that a population dynamics model, interaction model or rate model, to be considered, built and tested in isolation. This can produce building blocks of reusable components which can then be connected together in a modular and highly general way. These connections automatically build composite functions and complex differential equations in a compilation process which shields the user from the tedious and mistake-prone process of forming equations by hand.</p> <p>Modular modelling with functions and differential equations</p>"},{"location":"overview/introduction/#intended-use","title":"Intended use","text":"<p>This package is primarily a system for building complex system models consisting of multiple (potentially hundreds or thousands) of variables, functions and differential equations. As such, while it can be used as a numerical simulator for systems whose differential equations are known, it is often easier to pass such systems straight to a specialised numerical solver. The strength of <code>psymple</code> is being able to produce such simulable systems in cases where it is too time-consuming to do so by hand.</p>"},{"location":"overview/introduction/#modern-modelling","title":"Modern modelling","text":"<p><code>psymple</code> subscribes to the emerging theory of collaborative modelling, the practice of multiple contributors collaborating to build complex systems models. This requires modular, reusable components which naturally fit together, built with clarity and clear records of assumptions, data sources and expertise inputs. </p> <p>The collaboration of many domain experts often presents challenges with different technical languages or interpretations of concepts. <code>psymple</code> adopts a data-first design for its main objects which allows them to be built from, or dismantled into, wide-ranging formats.</p> <p>Read more about the design principles</p>"},{"location":"overview/modelling_systems/","title":"Hybrid systems modelling","text":"<p>The package <code>psymple</code> implements the building and simulation of temporal dynamical systems models. While the package is designed to allow for the implementation of very general modelling paradigms, it was developed in response to the need for hybrid temporal ecological modelling.</p>"},{"location":"overview/modelling_systems/#some-background-in-ecological-modelling","title":"Some background in ecological modelling","text":"<p>Temporal ecological modelling has classically been approached from two different schools of thought:</p> <ol> <li> <p>Mechanistic modelling, in which biological or physical principles are used to capture the flow of energy or resource between different species and systems in order to model population dynamics.</p> <p>Read more about mechanistic modelling</p> </li> <li> <p>Correlative modelling, in which a population distribution or other factor such as a suitability index is modelled as a function of climatic, environmental or geographic predictor variables such as temperature, rainfall, soil type or altitude.</p> <p>Read more about correlative modelling</p> </li> </ol> <p>Since biological processes are complex and intricate, mechanistic modelling of ecological systems is not widely pursued due to concerns about development time and accuracy. In contrast, correlative modelling is typically derived using multiple regression or machine learning techniques, requiring few variables and allowing for rapid assessments.</p>"},{"location":"overview/modelling_systems/#hybrid-modelling","title":"Hybrid modelling","text":"<p>Correlative modelling, however, has a natural limitation when used for predictive purposes in geographic or climatic ranges outside of the observational data. This becomes a particular concern when, for example, using correlative modelling to predict invasive species potential in new environments.</p> <p>In response, and with the advances in computing capability, there has been growing interest in hybrid or spectrum models, which compose features of both mechanistic and correlative models. This package was initially designed to facilitate the construction of these models by easily allowing arbitrary combinations of mechanistic and correlative components.</p> <p>Read more about spectrum modelling</p>"},{"location":"overview/modelling_types/","title":"Mechanistic and correlative models","text":"<p>This page gives an overview of what is meant by mechanistic and correlative models in the context of <code>psymple</code>.</p>"},{"location":"overview/modelling_types/#mechanistic-models","title":"Mechanistic models","text":"<p>Mechanistic models are dynamic models in which the evolution of the system is specified as a system of first-order ordinary differential equations (ODEs). </p> <p>Definition: mechanistic model</p> <p>A mechanistic dynamic system model is of the form</p> \\[  \\frac{d \\underline{x}}{dt} = \\underline{f}(\\underline{x}, t, \\underline{b}) \\] <p>where \\(\\underline{x} = \\underline{x}(t)\\) are system states or variables and \\(\\underline{b} = \\underline{b}(t)\\) are external dependencies. </p> <p>A familiar example of a mechanistic model is the Lotka-Volterra or predator-prey system.</p> <p>Example: predator-prey system</p> <p>A two-species predator prey system has the form</p> \\[ \\begin{align} \\frac{dx}{dt} &amp;= \\alpha x - \\beta xy \\\\ \\frac{dy}{dt} &amp;= \\gamma xy - \\delta y \\end{align} \\] <p>where:</p> <ul> <li>\\(\\alpha &gt; 0\\) is the birth rate of prey population \\(x\\), </li> <li>\\(\\delta&gt;0\\) is the death rate of predator population \\(y\\), </li> <li>\\(\\beta&gt;0\\) is the predation rate of \\(y\\) on \\(x\\), </li> <li>\\(\\gamma&gt;0\\) is the response rate of \\(y\\) from the predation on \\(x\\).</li> </ul>"},{"location":"overview/modelling_types/#correlative-models","title":"Correlative models","text":"<p>A correlative model is a general term for a model in which the evolution is specified explicitly in terms of time and the system states.</p> <p>Definition: correlative model</p> <p>A correlative model is of the form</p> \\[ \\underline{y} = \\underline{f}(t, \\underline{d}) \\] <p>where \\(\\underline{y} = \\underline{y}(t)\\) is a vector of system states and \\(\\underline{d} = \\underline{d}(t)\\) are external dependencies.</p> <p>Correlative models can be used to approximate the behaviour of a system component with other system states.</p> <p>Example: correlative ecological niche models</p> <p>Data may be used to model the prevalence of a certain species \\(y\\) in response to temporal climatic features such as temperature \\(T\\), relative humidity \\(H_r\\) and precipitation \\(P\\). In this case the model will have the form</p> \\[ y(t) = f(T, H_r, P) \\] <p>where \\(T=T(t)\\), \\(H_r = H_r(t)\\) and \\(P=P(t)\\) are known in terms of \\(t\\).</p>"},{"location":"overview/modelling_types/#spectrum-models","title":"Spectrum models","text":"<p>In <code>psymple</code>, spectrum models consisting of building blocks from purely mechanistic models and purely correlative models can be constructed by allowing arbitrary combinations of ordinary differential equations (ODEs) and multivariate functions to be combined together. A system in <code>psymple</code> is therefore of the form:</p> \\[ \\begin{align} \\frac{d \\underline{x}}{dt} &amp;= \\underline{f}(\\underline{x}, \\underline{y}, t, \\underline{b}) \\\\ \\underline{y} &amp;= \\underline{g}(t, \\underline{d}) \\\\ \\underline{b} &amp;= \\underline{h}(t) \\end{align} \\]"},{"location":"overview/statement_of_need/","title":"Statement of need","text":"<p>The development of <code>psymple</code> emerged from the complex system modelling requirements of ecological systems. Ecological niche models, also called species distribution models (SDMs) predict species distributions in response to environmental variables such as geographic and climatic features. Classically, these models are formed using correlative or statistical approaches which match observational data to a set of environmental variables to produce favourability ranges for each species.</p> <p>An alternative approach is mechanistic modelling, which instead of observational data use physiological data to capture the underlying mechanisms which drive species distribution, such as energy balance, population dynamics or response to climate. In contrast to correlative approaches, mechanistic SDMs decouple the physiology of a species from their native geography or climate, and allow SDMs in new geographic or climatic regimes to be created in the absence of observational data. </p> <p>An example mechanistic framework is physiologically-based demographic modelling (PBDM), which creates holistic ecosystem models based on the weather-driven biology of component species, allowing for predictive phenology, age- or mass-structured population dynamics, and distribution assessments. With this approach, PBDM can account for tritrophic ecosystem interactions, or model the effects of climate change.</p> <p>The schools of thought around correlative SDMs and mechanistic frameworks such as PBDM are seen as largely disjoint, but their development can be traced back to early common roots. A component of the PBDM framework is the use of physiological data to parametrise \"biodemographic\" functions capturing biophysical or biochemical mechanisms, such as the development, mortality and fecundity rates of a species in response to environmental variables.</p> <p>The use of biodemographic functions in PBDM combines the considerable holistic advantages of mechanistic SDMs, while retaining the comparable ease of parametrisation as status-quo correlative models. More widely, there has been growing interest and development of ecological models explicitly composed of both correlative and mechanistic components, combining the benefits of both areas. In the wider context of complex systems modelling, the approach of building composite models out of different techniques is called hybrid, or spectrum, modelling.  </p> <p>While PBDM is a highly-developed framework, it shares the same barriers to widespread introduction as general hybrid complex system models. These barriers include the lack of available modelling frameworks, the lack of flexibility in existing models, or the lack of modelling platforms to implement existing ideas. The package <code>psymple</code> is a general platform designed to facilitate the creation of hybrid complex systems models and modelling frameworks. </p> <p>Models in <code>psymple</code> are built from arbitrary combinations of modular mechanistic, dynamic components and correlative, functional components which naturally interact with each other. This structure allows for the systematic implementation of modelling frameworks such as PBDM, and, more widely, those capturing biological, economic and social systems, for which it is not feasible to capture the laws of interaction purely mechanistically. Examples include agroecological, bioeconomic and Earth systems modelling, and the development of <code>psymple</code> is a necessary first step in the development and release of accessible and impactful tools in these areas. </p>"},{"location":"overview/system_design/","title":"System design","text":"<p><code>psymple</code> is built to maximise accessibility and reusability by incorporating the following principles at the core of the design.</p>"},{"location":"overview/system_design/#1-modular-components","title":"1. Modular components","text":"<p>Systems of any complexity can be modelled by versatile building blocks called \"ported objects\" which can be nested into arbitrary hierarchies to capture the structure of the system being modelled.</p> <p>These objects can be linked by \"wires\" which formally represent the flow of resource or information around the system. This provides a degree of separation from the modeller to the dynamically-created system equations, which provides:</p> <ol> <li>Faceted approach: each component can be conceived, built and tested in isolation from the system.</li> <li>Diagrammatic interface: complex systems are often visualised through diagrams representing the interconnectivity. The interface to <code>psymple</code> is a codified approach to building these diagrams.</li> <li>Natural interaction: connections from other parts in the system can override default behaviours and capture information or composite variable dynamics automatically.</li> </ol>"},{"location":"overview/system_design/#2-symbolic-systems","title":"2. Symbolic systems","text":"<p>The python mathematics library sympy allows for system models to be built, stored and manipulated symbolically. This feature is designed to provide:</p> <ol> <li>Clarity: any system component can produce its own system of equations for easy inspection and checking.</li> <li>Dependability: models built using computer algebra removes mistakes in combining multiple components.</li> <li>Efficiency: systems built from many parts produce complex equations which can be automatically simplified to aid simulation.</li> </ol>"},{"location":"overview/system_design/#3-data-first-design","title":"3. Data-first design","text":"<p>Systems are built and stored using a flexible <code>json</code> data model for its main objects which allows them to be built from, or dismantled into, wide-ranging formats. This is designed to provide:</p> <ol> <li>Collaborative modelling: varied domain experts with different technical languages or interpretations of concepts can develop and interact with different interfaces to the core data format. Read more about collaborative modelling.</li> <li>Traceability: a data-centric focus provides a more natural setting to integrate data and assumption sources into the platform for clear and trustable model creation.</li> <li>Language-agnosticism: the choice to build <code>psymple</code> in <code>python</code> is designed to maximise its scalability and uptake. Implementations in other languages may have other advantages, but can be built with the same core data format.</li> </ol>"},{"location":"reference/variables/","title":"Variables","text":""},{"location":"reference/variables/#psymple.abstract.SymbolWrapper","title":"<code>SymbolWrapper(symbol, description='')</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A class storing a <code>sympy.Symbol</code> instance with other attributes.</p> PARAMETER DESCRIPTION <code>symbol</code> <p>the symbol to wrap</p> <p> TYPE: <code>str | Symbol</code> </p> <code>description</code> <p>an optional description of the container contents</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>psymple/abstract.py</code> <pre><code>def __init__(self, symbol: str | Symbol, description: str = \"\"):\n    \"\"\"\n    Create a SymbolWrapper instance.\n\n    Args:\n        symbol: the symbol to wrap\n        description: an optional description of the container contents\n    \"\"\"\n    if isinstance(symbol, str):\n        symbol = Symbol(symbol)\n    self.symbol = symbol\n    self.description = description\n</code></pre>"},{"location":"reference/variables/#psymple.variables.Variable","title":"<code>Variable(symbol, description='')</code>","text":"<p>               Bases: <code>SymbolWrapper</code></p> <p>A variable is a <code>SymbolWrapper</code> instance together with a description.</p> Source code in <code>psymple/abstract.py</code> <pre><code>def __init__(self, symbol: str | Symbol, description: str = \"\"):\n    \"\"\"\n    Create a SymbolWrapper instance.\n\n    Args:\n        symbol: the symbol to wrap\n        description: an optional description of the container contents\n    \"\"\"\n    if isinstance(symbol, str):\n        symbol = Symbol(symbol)\n    self.symbol = symbol\n    self.description = description\n</code></pre>"},{"location":"reference/variables/#psymple.variables.Parameter","title":"<code>Parameter(symbol, value, description='')</code>","text":"<p>               Bases: <code>SymbolWrapper</code></p> <p>A parameter is a <code>SymbolWrapper</code> instance together with an  equivalent value and description.</p> PARAMETER DESCRIPTION <code>symbol</code> <p>the symbol to wrap.</p> <p> TYPE: <code>str | Symbol</code> </p> <code>value</code> <p>the value represented by <code>symbol</code>.</p> <p> TYPE: <code>str | float | Basic</code> </p> <code>description</code> <p>an optional description of the container contents.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>psymple/variables.py</code> <pre><code>def __init__(self, symbol: str | Symbol, value: str | float | Basic, description: str = \"\"):\n    \"\"\"\n    Create a Parameter instance.\n\n    Args:\n        symbol: the symbol to wrap.\n        value: the value represented by `symbol`.\n        description: an optional description of the container contents.\n    \"\"\"\n    super().__init__(symbol, description)\n    self.value = value\n</code></pre>"},{"location":"reference/variables/#psymple.abstract.ExpressionWrapper","title":"<code>ExpressionWrapper(expression, parsing_locals={})</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A class storing a <code>sympy.Basic</code> object: anything returned by <code>sympy.sympify</code>.</p> PARAMETER DESCRIPTION <code>expression</code> <p>the expression to wrap. If it is not a <code>sympy</code> object, it is  parsed into one first.</p> <p> TYPE: <code>Basic | str | float | int</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to sympy objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/abstract.py</code> <pre><code>def __init__(self, expression: Basic | str | float | int, parsing_locals: dict = {}):\n    \"\"\"\n    Create an ExpressionWrapper instance\n\n    Args:\n        expression: the expression to wrap. If it is not a `sympy` object, it is \n            parsed into one first.\n        parsing_locals: a dictionary mapping strings to sympy objects.\n    \"\"\"\n    if expression is not None:\n        if isinstance(expression, str):\n            expression = parse_expr(expression, local_dict=parsing_locals)\n        elif isinstance(expression, (int, float)):\n            expression = Number(expression)\n        if not isinstance(expression, Basic):\n            raise ParsingError(f\"Expression {expression} of type {type(expression)} is not an accepted type.\")\n    self.expression = expression\n</code></pre>"},{"location":"reference/variables/#psymple.variables.UpdateRule","title":"<code>UpdateRule(expression=0, variables=set(), parameters=set(), description='')</code>","text":"<p>               Bases: <code>ExpressionWrapper</code></p> <p>An update rule is an <code>ExpressionWrapper</code> that is attached to a <code>Variable</code> or <code>Parameter</code> instance. It stores how the variable or parameter will evolve over time. An update rule tracks the other variables or parameters which appear in its expression, so that it is fully aware of its system dependencies.</p> METHOD DESCRIPTION <code>sub_symbols</code> <p>substitute the symbols contained inside <code>self</code>.</p> PARAMETER DESCRIPTION <code>expression</code> <p>the expression to wrap. If it is not a <code>sympy</code> object, it is  parsed into one first.</p> <p> TYPE: <code>Basic | str | float | int</code> DEFAULT: <code>0</code> </p> <code>variables</code> <p>a set of variables of which the variables in the expression are a subset</p> <p> TYPE: <code>set</code> DEFAULT: <code>set()</code> </p> <code>parameters</code> <p>a set of parameters of which the parameters in the expression are a subset</p> <p> TYPE: <code>set</code> DEFAULT: <code>set()</code> </p> <code>description</code> <p>description of the rule</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>psymple/variables.py</code> <pre><code>def __init__(\n    self,\n    expression: Basic | str | float | int = 0,\n    variables: set = set(),\n    parameters: set = set(),\n    description: str = \"\",\n):\n    \"\"\"\n    Create an UpdateRule instance.\n\n    Args:\n        expression: the expression to wrap. If it is not a `sympy` object, it is \n            parsed into one first.\n        variables: a set of variables of which the variables in the expression are a subset\n        parameters: a set of parameters of which the parameters in the expression are a subset\n        description: description of the rule\n    \"\"\"\n    super().__init__(expression)\n    self._initialise_dependencies(variables, parameters)\n    self.description = description\n    self._equation_lambdified = None\n</code></pre>"},{"location":"reference/variables/#psymple.variables.UpdateRule.sub_symbols","title":"<code>sub_symbols(vars_dict, pars_dict)</code>","text":"<p>Substitute the variables and parameters of <code>self</code> according to dictionary mappings.</p> PARAMETER DESCRIPTION <code>vars_dict</code> <p>a dictionary providing mappings between <code>sympy.Symbol</code> objects</p> <p> TYPE: <code>dict</code> </p> <code>pars_dict</code> <p>a dictionary providing mappings between <code>sympy.Symbol</code> objects</p> <p> TYPE: <code>dict</code> </p> Source code in <code>psymple/variables.py</code> <pre><code>def sub_symbols(self, vars_dict: dict, pars_dict: dict):\n    \"\"\"\n    Substitute the variables and parameters of `self` according to dictionary mappings.\n\n    Args:\n        vars_dict: a dictionary providing mappings between `sympy.Symbol` objects\n        pars_dict: a dictionary providing mappings between `sympy.Symbol` objects\n    \"\"\"\n    vars_dict_filter = {symbol: vars_dict[symbol] for symbol in self.variables}\n    pars_dict_filter = {symbol: pars_dict[symbol] for symbol in self.parameters}\n    subbed_vars = {vars_dict[v] for v in self.variables}\n    subbed_pars = {pars_dict[p] for p in self.parameters}\n    subbed_expr = self.expression.subs(vars_dict_filter | pars_dict_filter)\n    self.variables = subbed_vars\n    self.parameters = subbed_pars\n    self.expression = subbed_expr\n</code></pre>"},{"location":"reference/build/assignments/","title":"Assignments","text":""},{"location":"reference/build/assignments/#psymple.build.assignments.Assignment","title":"<code>Assignment(symbol, expression, parsing_locals={})</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for storing a symbol wrapper together with a symbolic expression. An assignment is a formal equality between the symbol wrapper and the expression.</p> PARAMETER DESCRIPTION <code>symbol</code> <p>LHS of the assignment (e.g. parameter or variable). If input is a string,  it is converted to a SymbolWrapper instance.</p> <p> TYPE: <code>str</code> </p> <code>expression</code> <p>expression on the RHS. If input is a string or number,  it is converted to a sympy expression.</p> <p> TYPE: <code>Basic | str | float | int</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to sympy objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/abstract.py</code> <pre><code>def __init__(self, symbol: str, expression: Basic | str | float | int, parsing_locals: dict={}):\n    \"\"\"\n    Instantiate an Assignment.\n\n    Args:\n        symbol: LHS of the assignment (e.g. parameter or variable). If input is a string, \n            it is converted to a [SymbolWrapper][psymple.abstract.SymbolWrapper] instance.\n        expression: expression on the RHS. If input is a string or number, \n            it is converted to a sympy expression.\n        parsing_locals: a dictionary mapping strings to sympy objects.\n    \"\"\"\n    self.symbol_wrapper = SymbolWrapper(symbol)\n    self.expression_wrapper = ExpressionWrapper(expression, parsing_locals)\n</code></pre>"},{"location":"reference/build/assignments/#psymple.build.assignments.DifferentialAssignment","title":"<code>DifferentialAssignment(symbol, expression, parsing_locals={})</code>","text":"<p>               Bases: <code>Assignment</code></p> <p>Class storing an ODE of the form \\( dx/dt = f(x,t,b) \\) where \\( b \\) is a list of  external dependencies.</p> PARAMETER DESCRIPTION <code>symbol</code> <p>LHS of the assignment containing the variable derivative.  If input is a string, it is converted to a SymbolWrapper instance.</p> <p> TYPE: <code>str</code> </p> <code>expression</code> <p>function on the RHS. If input is a string or number,  it is converted to a sympy expression.</p> <p> TYPE: <code>Expr | str | float | int</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to sympy objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/build/assignments.py</code> <pre><code>def __init__(self, symbol: str, expression: Expr | str | float | int, parsing_locals: dict={}):\n    \"\"\"\n    Intantiate a DifferentialAssignment. \n\n    Args:\n        symbol: LHS of the assignment containing the variable derivative. \n            If input is a string, it is converted to a [SymbolWrapper][psymple.abstract.SymbolWrapper] instance.\n        expression: function on the RHS. If input is a string or number, \n            it is converted to a sympy expression.\n        parsing_locals: a dictionary mapping strings to sympy objects.\n    \"\"\"\n    super().__init__(symbol, expression, parsing_locals)\n    # Coerce self.symbol_wrapper into instance of Variable.\n    if type(self.symbol_wrapper) is SymbolWrapper:\n        self.symbol_wrapper = Variable(\n            symbol=self.symbol_wrapper.symbol,\n            description=self.symbol_wrapper.description,\n        )\n</code></pre>"},{"location":"reference/build/assignments/#psymple.build.assignments.ParameterAssignment","title":"<code>ParameterAssignment(symbol, expression, parsing_locals={})</code>","text":"<p>               Bases: <code>Assignment</code></p> <p>Class storing an assignment of the form \\( y = f(x,t,b) \\), where \\( b \\) is a list of external dependencies.</p> PARAMETER DESCRIPTION <code>symbol</code> <p>LHS of the assignment containing the parameter name.  If input is a string, it is converted to a SymbolWrapper instance.</p> <p> TYPE: <code>str</code> </p> <code>expression</code> <p>function on the RHS. If input is a string or number,  it is converted to a sympy expression.</p> <p> TYPE: <code>Expr | str | float | int</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to sympy objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/build/assignments.py</code> <pre><code>def __init__(self, symbol: str, expression: Expr | str | float | int, parsing_locals: dict={}):\n    \"\"\"\n    Instantiate a ParameterAssignment. \n\n    Args:\n        symbol: LHS of the assignment containing the parameter name. \n            If input is a string, it is converted to a [SymbolWrapper][psymple.abstract.SymbolWrapper] instance.\n        expression: function on the RHS. If input is a string or number, \n            it is converted to a sympy expression.\n        parsing_locals: a dictionary mapping strings to sympy objects.\n    \"\"\"\n    super().__init__(symbol, expression, parsing_locals)\n    # We ensure we that the symbol_wrapper is instance of Parameter.\n    if type(self.symbol_wrapper) is SymbolWrapper:\n        self.symbol_wrapper = Parameter(\n            self.symbol_wrapper.symbol,\n            self.expression,\n            self.symbol_wrapper.description,\n        )\n    # We forbid the symbol wrapper to appear in the expression eg. R=2*R unless the expression\n    # and symbol are identical\n    if (self.symbol in self.expression.free_symbols) and (self.symbol != self.expression):\n        raise DependencyError(\n            f\"The symbol {self.symbol} cannot appear as both the function \"\n            f\"value and argument of {self}.\"\n        )\n</code></pre>"},{"location":"reference/build/assignments/#psymple.build.assignments.FunctionalAssignment","title":"<code>FunctionalAssignment(symbol, expression, parsing_locals={})</code>","text":"<p>               Bases: <code>ParameterAssignment</code></p> <p>A convenience class to identify parameters which have been constructed from the OutputPort of a FunctionalPortedObject. These represent the core functional building blocks of a System.</p> Source code in <code>psymple/build/assignments.py</code> <pre><code>def __init__(self, symbol: str, expression: Expr | str | float | int, parsing_locals: dict={}):\n    \"\"\"\n    Instantiate a ParameterAssignment. \n\n    Args:\n        symbol: LHS of the assignment containing the parameter name. \n            If input is a string, it is converted to a [SymbolWrapper][psymple.abstract.SymbolWrapper] instance.\n        expression: function on the RHS. If input is a string or number, \n            it is converted to a sympy expression.\n        parsing_locals: a dictionary mapping strings to sympy objects.\n    \"\"\"\n    super().__init__(symbol, expression, parsing_locals)\n    # We ensure we that the symbol_wrapper is instance of Parameter.\n    if type(self.symbol_wrapper) is SymbolWrapper:\n        self.symbol_wrapper = Parameter(\n            self.symbol_wrapper.symbol,\n            self.expression,\n            self.symbol_wrapper.description,\n        )\n    # We forbid the symbol wrapper to appear in the expression eg. R=2*R unless the expression\n    # and symbol are identical\n    if (self.symbol in self.expression.free_symbols) and (self.symbol != self.expression):\n        raise DependencyError(\n            f\"The symbol {self.symbol} cannot appear as both the function \"\n            f\"value and argument of {self}.\"\n        )\n</code></pre>"},{"location":"reference/build/assignments/#psymple.build.assignments.DefaultParameterAssignment","title":"<code>DefaultParameterAssignment(symbol, expression, parsing_locals={})</code>","text":"<p>               Bases: <code>ParameterAssignment</code></p> <p>A convenience class to identify parameters which have been constructed from default values. These represent those system parameters which are changeable.</p> Source code in <code>psymple/build/assignments.py</code> <pre><code>def __init__(self, symbol: str, expression: Expr | str | float | int, parsing_locals: dict={}):\n    \"\"\"\n    Instantiate a ParameterAssignment. \n\n    Args:\n        symbol: LHS of the assignment containing the parameter name. \n            If input is a string, it is converted to a [SymbolWrapper][psymple.abstract.SymbolWrapper] instance.\n        expression: function on the RHS. If input is a string or number, \n            it is converted to a sympy expression.\n        parsing_locals: a dictionary mapping strings to sympy objects.\n    \"\"\"\n    super().__init__(symbol, expression, parsing_locals)\n    # We ensure we that the symbol_wrapper is instance of Parameter.\n    if type(self.symbol_wrapper) is SymbolWrapper:\n        self.symbol_wrapper = Parameter(\n            self.symbol_wrapper.symbol,\n            self.expression,\n            self.symbol_wrapper.description,\n        )\n    # We forbid the symbol wrapper to appear in the expression eg. R=2*R unless the expression\n    # and symbol are identical\n    if (self.symbol in self.expression.free_symbols) and (self.symbol != self.expression):\n        raise DependencyError(\n            f\"The symbol {self.symbol} cannot appear as both the function \"\n            f\"value and argument of {self}.\"\n        )\n</code></pre>"},{"location":"reference/build/compilation/","title":"Compilation","text":""},{"location":"reference/build/compilation/#psymple.build.compiled_ports.CompiledPort","title":"<code>CompiledPort(port, assignment)</code>","text":"<p>               Bases: <code>Port</code></p> <p>A port object together with the assignment it exposes.</p> Note <p>This class is not designed to be instantiated directly.</p> PARAMETER DESCRIPTION <code>port</code> <p>port to compile</p> <p> TYPE: <code>Port</code> </p> <code>assignment</code> <p>assignment to assign to the port</p> <p> TYPE: <code>Assignment</code> </p> Source code in <code>psymple/build/compiled_ports.py</code> <pre><code>def __init__(self, port: Port, assignment: Assignment):\n    \"\"\"\n    Instantiate from a port and assignment.\n\n    Args:\n        port: port to compile\n        assignment: assignment to assign to the port\n    \"\"\"\n    self.name = port.name\n    self.assignment = deepcopy(assignment)\n    self.description = port.description\n</code></pre>"},{"location":"reference/build/compilation/#psymple.build.ported_objects.CompiledPortedObject","title":"<code>CompiledPortedObject(name, parsing_locals={}, **kwargs)</code>","text":"<p>               Bases: <code>CompositePortedObject</code></p> <p>A ported object with compiled ports store exposable assignments, together with internal assignments.</p> Note: <p>This class should not be instantiated on its own. It is formed from the <code>compile</code> methods of 1PortedObject1 subclasses.</p> PARAMETER DESCRIPTION <code>name</code> <p>a string which must be unique for each <code>PortedObject</code> inside a common <code>CompositePortedObject</code>.</p> <p> TYPE: <code>str</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to <code>sympy</code> objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>**kwargs</code> <p>arguments passed to super().init(). No user arguments should be supplied.</p> <p> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def __init__(self, name: str, parsing_locals: dict = {}, **kwargs):\n    \"\"\"\n    Instantiate a CompiledPortedObject.\n\n    Args:\n        name: a string which must be unique for each `PortedObject` inside a common\n            [`CompositePortedObject`][psymple.build.CompositePortedObject].\n        parsing_locals: a dictionary mapping strings to `sympy` objects.\n        **kwargs: arguments passed to super().__init__(). No user arguments should be supplied.\n    \"\"\"\n    super().__init__(name, parsing_locals=parsing_locals, **kwargs)\n    # free input parameters and (possibly) their default values\n    self.input_ports = {}\n    # values of output parameters in terms of input parameters\n    self.output_ports = {}\n    # ODEs of variables in terms of input parameters and other variables\n    self.variable_ports = {}\n    # ODEs of unexposed variables in terms of other parameters and variables\n    self.internal_variable_assignments = {}\n    # Parameters that are initialized via default parameters, and whose values are fully determined\n    self.internal_parameter_assignments = {}\n    # Inputs of self which must be provided before simulation\n    self.required_inputs = {}\n</code></pre>"},{"location":"reference/build/compilation/#psymple.build.ported_objects.CompiledPortedObject.get_assignments","title":"<code>get_assignments()</code>","text":"<p>Returns all assignments of self.</p> <ul> <li>The first return value is all assignments at variable ports and all     internal variable assignments,</li> <li>The second return value is all assignments at output ports and all     internal parameter assignments.</li> </ul> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def get_assignments(\n    self,\n) -&gt; tuple[list[DifferentialAssignment], list[ParameterAssignment]]:\n    \"\"\"\n    Returns all assignments of self.\n\n    - The first return value is all assignments at variable ports and all\n        internal variable assignments,\n    - The second return value is all assignments at output ports and all\n        internal parameter assignments.\n    \"\"\"\n    self._set_input_parameters()\n\n    parameter_assignments = list(\n        itertools.chain(\n            (p.assignment for p in self.output_ports.values()),\n            self.internal_parameter_assignments.values(),\n        )\n    )\n    variable_assignments = list(\n        itertools.chain(\n            (p.assignment for p in self.variable_ports.values()),\n            self.internal_variable_assignments.values(),\n        )\n    )\n\n    return variable_assignments, parameter_assignments\n</code></pre>"},{"location":"reference/build/compilation/#psymple.build.ported_objects.CompiledPortedObject.get_required_inputs","title":"<code>get_required_inputs()</code>","text":"<p>Returns the input parameters of <code>self</code> which do not have a default value.</p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def get_required_inputs(self) -&gt; set[RequiredInputParameter]:\n    \"\"\"\n    Returns the input parameters of `self` which do not have a default value.\n    \"\"\"\n    return list(self.required_inputs.values())\n</code></pre>"},{"location":"reference/build/data/","title":"Data","text":""},{"location":"reference/build/data/#psymple.build.PortedObjectData","title":"<code>PortedObjectData(*, metadata, object_data)</code>","text":"<p>               Bases: <code>dict</code></p> <p>A dictionary holding the information defining a PortedObject instance.</p> PARAMETER DESCRIPTION <code>metadata</code> <p>dictionary storing ported object identifiers including <code>\"name\"</code> and <code>\"type\"</code></p> <p> TYPE: <code>dict</code> </p> <code>object_data</code> <p>dictionary to be passed to ported object constructor</p> <p> TYPE: <code>dict</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def __init__(self, *, metadata: dict, object_data: dict):\n    \"\"\"\n    Create a PortedObjectData instance.\n\n    Args:\n        metadata: dictionary storing ported object identifiers including `\"name\"`\n            and `\"type\"`\n        object_data: dictionary to be passed to ported object constructor\n    \"\"\"\n    self._check_metadata(metadata)\n    self._check_object_data(object_data)\n    super().__init__(metadata=metadata, object_data=object_data)\n</code></pre>"},{"location":"reference/build/data/#psymple.build.PortedObjectData.to_ported_object","title":"<code>to_ported_object(parsing_locals={})</code>","text":"<p>Builds a <code>PortedObject</code> instance from self. The type of <code>PortedObject</code> is read from <code>self.type</code> and must be one of <code>\"fpo\"</code>, <code>\"vpo\"</code> or <code>\"cpo\"</code>.</p> PARAMETER DESCRIPTION <code>parsing_locals</code> <p>a dictionary mapping strings to <code>sympy</code> objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>PortedObject</code> <p>An instance of (or subclass of) <code>PortedObject</code> formed by passing <code>parsing_locals</code> and <code>**self.object_data</code> to the constructor indicated by <code>self.type</code>.</p> <p> TYPE: <code>PortedObject</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def to_ported_object(self, parsing_locals: dict = {}) -&gt; PortedObject:\n    \"\"\"\n    Builds a [`PortedObject`][psymple.build.abstract.PortedObject] instance from self.\n    The type of `PortedObject` is read from `self.type` and must be one of `\"fpo\"`, `\"vpo\"` or `\"cpo\"`.\n\n    Args:\n        parsing_locals: a dictionary mapping strings to `sympy` objects.\n\n    Returns:\n        PortedObject: An instance of (or subclass of) `PortedObject` formed by\n            passing `parsing_locals` and `**self.object_data` to the constructor indicated by\n            `self.type`.\n    \"\"\"\n    PORTED_OBJECT_TYPES = {\n        \"fpo\": FunctionalPortedObject,\n        \"vpo\": VariablePortedObject,\n        \"cpo\": CompositePortedObject,\n    }\n    name = self.name\n    type = self.type\n    data = self.data\n    ported_object = PORTED_OBJECT_TYPES[type]\n    return ported_object(name=name, parsing_locals=parsing_locals, **data)\n</code></pre>"},{"location":"reference/build/ported_objects/","title":"Ported objects","text":""},{"location":"reference/build/ported_objects/#psymple.build.ported_objects.PortedObject","title":"<code>PortedObject(name, input_ports=[], output_ports=[], variable_ports=[], parsing_locals={}, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class implementing ported objects. Cannot be instantiated directly.</p> PARAMETER DESCRIPTION <code>name</code> <p>a string which must be unique for each <code>PortedObject</code> inside a common <code>CompositePortedObject</code>.</p> <p> TYPE: <code>str</code> </p> <code>input_ports</code> <p>list of input ports to expose. See add_input_ports.</p> <p> TYPE: <code>list[InputPort | dict | tuple | str]</code> DEFAULT: <code>[]</code> </p> <code>output_ports</code> <p>list of output ports to expose. See add_output_ports.</p> <p> TYPE: <code>list[OutputPort | dict | str]</code> DEFAULT: <code>[]</code> </p> <code>variable_ports</code> <p>list of variable ports to expose. See add_variable_ports.</p> <p> TYPE: <code>list[VariablePort | dict | str]</code> DEFAULT: <code>[]</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to <code>sympy</code> objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>**kwargs</code> <p>arguments passed to super().init(). No user arguments should be supplied.</p> <p> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/build/abstract.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    input_ports: list[InputPort | dict | tuple | str] = [],\n    output_ports: list[OutputPort | dict | str] = [],\n    variable_ports: list[VariablePort | dict | str] = [],\n    parsing_locals: dict = {},\n    **kwargs,\n):\n    \"\"\"\n    Construct a PortedObject.\n\n    Args:\n        name: a string which must be unique for each `PortedObject` inside a common\n            [`CompositePortedObject`][psymple.build.CompositePortedObject].\n        input_ports: list of input ports to expose.\n            See [add_input_ports][psymple.build.abstract.PortedObject.add_input_ports].\n        output_ports: list of output ports to expose.\n            See [add_output_ports][psymple.build.abstract.PortedObject.add_input_ports].\n        variable_ports: list of variable ports to expose.\n            See [add_variable_ports][psymple.build.abstract.PortedObject.add_variable_ports].\n        parsing_locals: a dictionary mapping strings to `sympy` objects.\n        **kwargs: arguments passed to super().__init__(). No user arguments should be supplied.\n    \"\"\"\n    self.name = name\n    # Ports exposed to the outside, indexed by their name\n    self.variable_ports = {}\n    self.input_ports = {}\n    self.output_ports = {}\n\n    self.parsing_locals = parsing_locals\n    self.add_input_ports(*input_ports)\n    self.add_output_ports(*output_ports)\n    self.add_variable_ports(*variable_ports)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.ported_objects.PortedObject.add_input_ports","title":"<code>add_input_ports(*ports)</code>","text":"<p>Add input ports to self.</p> PARAMETER DESCRIPTION <code>*ports</code> <p>data specifying an input port, in the form of:</p> <ul> <li>an <code>InputPort</code> instance;</li> <li>a dictionary specifying \"name\", and optionally \"description\" and \"default_value\";</li> <li>a tuple, with the first entry specifying the name, and the second the default value;</li> <li>a string, specifying the name of the port.</li> </ul> <p>Arguments can contain a mixture of the above data formats.</p> <p> TYPE: <code>InputPort | dict | tuple | str</code> DEFAULT: <code>()</code> </p> <p>Examples:</p> <p>Using an InputPort instance:</p> <pre><code>&gt;&gt;&gt; from psymple.ported_objects import VariablePortedObject, InputPort\n&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_input_ports(InputPort(\"A\", default_value=6))\n&gt;&gt;&gt; X._dump_input_ports()\n[{'name': 'A', 'description': '', 'default_value': 6}]\n</code></pre> <p>Using a dictionary:</p> <pre><code>&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_input_ports(dict(name = \"A\", description = \"input port A\", default_value=6))\n&gt;&gt;&gt; X._dump_input_ports()\n[{'name': 'A', 'description': 'input port A', 'default_value': 6}]\n</code></pre> <p>Using a tuple:</p> <pre><code>&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_input_ports((\"A\", 6, \"input port A\"))\n&gt;&gt;&gt; X._dump_input_ports()\n[{'name': 'A', 'description': 'input port A', 'default_value': 6}]\n</code></pre> <p>Using a string (note that a description or default value cannot be specified):</p> <pre><code>&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_input_ports(\"A\")\n&gt;&gt;&gt; X._dump_input_ports()\n[{'name': 'A', 'description': '', 'default_value': None}]\n</code></pre> Source code in <code>psymple/build/abstract.py</code> <pre><code>def add_input_ports(self, *ports: InputPort | dict | tuple | str):\n    \"\"\"\n    Add input ports to self.\n\n    Args:\n        *ports: data specifying an input port, in the form of:\n\n            - an `InputPort` instance;\n            - a dictionary specifying \"name\", and optionally \"description\" and \"default_value\";\n            - a tuple, with the first entry specifying the name, and the second the default value;\n            - a string, specifying the name of the port.\n\n            Arguments can contain a mixture of the above data formats.\n\n    Examples:\n        Using an InputPort instance:\n        &gt;&gt;&gt; from psymple.ported_objects import VariablePortedObject, InputPort\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_input_ports(InputPort(\"A\", default_value=6))\n        &gt;&gt;&gt; X._dump_input_ports()\n        [{'name': 'A', 'description': '', 'default_value': 6}]\n\n        Using a dictionary:\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_input_ports(dict(name = \"A\", description = \"input port A\", default_value=6))\n        &gt;&gt;&gt; X._dump_input_ports()\n        [{'name': 'A', 'description': 'input port A', 'default_value': 6}]\n\n        Using a tuple:\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_input_ports((\"A\", 6, \"input port A\"))\n        &gt;&gt;&gt; X._dump_input_ports()\n        [{'name': 'A', 'description': 'input port A', 'default_value': 6}]\n\n        Using a string (note that a description or default value cannot be specified):\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_input_ports(\"A\")\n        &gt;&gt;&gt; X._dump_input_ports()\n        [{'name': 'A', 'description': '', 'default_value': None}]\n\n    \"\"\"\n    for port_info in ports:\n        port = self.parse_port_entry(port_info, InputPort)\n        self._add_input_port(port)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.ported_objects.PortedObject.add_output_ports","title":"<code>add_output_ports(*ports)</code>","text":"<p>Add input ports to self.</p> PARAMETER DESCRIPTION <code>*ports</code> <p>data specifying an output port, in the form of:</p> <ul> <li>an <code>OutputPort</code> instance;</li> <li>a dictionary specifying \"name\", and optionally \"description\";</li> <li>a string, specifying the name of the port.</li> </ul> <p>Arguments can contain a mixture of the above data formats.</p> <p> TYPE: <code>OutputPort | dict | str</code> DEFAULT: <code>()</code> </p> <p>Examples:</p> <p>Using an OutputPort instance:</p> <pre><code>&gt;&gt;&gt; from psymple.ported_objects import FunctionalPortedObject, OutputPort\n&gt;&gt;&gt; X = FunctionalPortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_output_ports(OutputPort(\"A\", description=\"output port A\"))\n&gt;&gt;&gt; X._dump_output_ports()\n[{'name': 'A', 'description': 'output port A'}]\n</code></pre> <p>Using a dictionary:</p> <pre><code>&gt;&gt;&gt; X = FunctionalPortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_output_ports(dict(name = \"A\", description = \"output port A\"))\n&gt;&gt;&gt; X._dump_output_ports()\n[{'name': 'A', 'description': 'output port A'}]\n</code></pre> <p>Using a string (note that a description or default value cannot be specified):</p> <pre><code>&gt;&gt;&gt; X = FunctionalPortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_output_ports(\"A\")\n&gt;&gt;&gt; X._dump_output_ports()\n[{'name': 'A', 'description': ''}]\n</code></pre> Source code in <code>psymple/build/abstract.py</code> <pre><code>def add_output_ports(self, *ports: OutputPort | dict | str):\n    \"\"\"\n    Add input ports to self.\n\n    Args:\n        *ports: data specifying an output port, in the form of:\n\n            - an `OutputPort` instance;\n            - a dictionary specifying \"name\", and optionally \"description\";\n            - a string, specifying the name of the port.\n\n            Arguments can contain a mixture of the above data formats.\n\n    Examples:\n        Using an OutputPort instance:\n        &gt;&gt;&gt; from psymple.ported_objects import FunctionalPortedObject, OutputPort\n        &gt;&gt;&gt; X = FunctionalPortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_output_ports(OutputPort(\"A\", description=\"output port A\"))\n        &gt;&gt;&gt; X._dump_output_ports()\n        [{'name': 'A', 'description': 'output port A'}]\n\n        Using a dictionary:\n        &gt;&gt;&gt; X = FunctionalPortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_output_ports(dict(name = \"A\", description = \"output port A\"))\n        &gt;&gt;&gt; X._dump_output_ports()\n        [{'name': 'A', 'description': 'output port A'}]\n\n        Using a string (note that a description or default value cannot be specified):\n        &gt;&gt;&gt; X = FunctionalPortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_output_ports(\"A\")\n        &gt;&gt;&gt; X._dump_output_ports()\n        [{'name': 'A', 'description': ''}]\n\n    \"\"\"\n    for port_info in ports:\n        port = self.parse_port_entry(port_info, OutputPort)\n        self._add_output_port(port)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.ported_objects.PortedObject.add_variable_ports","title":"<code>add_variable_ports(*ports)</code>","text":"<p>Add input ports to self.</p> PARAMETER DESCRIPTION <code>*ports</code> <p>data specifying a variable port, in the form of:</p> <ul> <li>a <code>VariablePort</code> instance;</li> <li>a dictionary specifying \"name\", and optionally \"description\";</li> <li>a string, specifying the name of the port.</li> </ul> <p>Arguments can contain a mixture of the above data formats.</p> <p> TYPE: <code>VariablePort | dict | str</code> DEFAULT: <code>()</code> </p> <p>Examples:</p> <p>Using an VariablePort instance:</p> <pre><code>&gt;&gt;&gt; from psymple.ported_objects import VariablePortedObject, VariablePort\n&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_variable_ports(VariablePort(\"A\", description=\"variable port A\"))\n&gt;&gt;&gt; X._dump_variable_ports()\n[{'name': 'A', 'description': 'variable port A'}]\n</code></pre> <p>Using a dictionary:</p> <pre><code>&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_variable_ports(dict(name = \"A\", description = \"variable port A\"))\n&gt;&gt;&gt; X._dump_variable_ports()\n[{'name': 'A', 'description': 'variable port A'}]\n</code></pre> <p>Using a string (note that a description or default value cannot be specified):</p> <pre><code>&gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n&gt;&gt;&gt; X.add_variable_ports(\"A\")\n&gt;&gt;&gt; X._dump_variable_ports()\n[{'name': 'A', 'description': ''}]\n</code></pre> Source code in <code>psymple/build/abstract.py</code> <pre><code>def add_variable_ports(self, *ports: VariablePort | dict | str):\n    \"\"\"\n    Add input ports to self.\n\n    Args:\n        *ports: data specifying a variable port, in the form of:\n\n            - a `VariablePort` instance;\n            - a dictionary specifying \"name\", and optionally \"description\";\n            - a string, specifying the name of the port.\n\n            Arguments can contain a mixture of the above data formats.\n\n    Examples:\n        Using an VariablePort instance:\n        &gt;&gt;&gt; from psymple.ported_objects import VariablePortedObject, VariablePort\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_variable_ports(VariablePort(\"A\", description=\"variable port A\"))\n        &gt;&gt;&gt; X._dump_variable_ports()\n        [{'name': 'A', 'description': 'variable port A'}]\n\n        Using a dictionary:\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_variable_ports(dict(name = \"A\", description = \"variable port A\"))\n        &gt;&gt;&gt; X._dump_variable_ports()\n        [{'name': 'A', 'description': 'variable port A'}]\n\n        Using a string (note that a description or default value cannot be specified):\n        &gt;&gt;&gt; X = VariablePortedObject(name=\"X\")\n        &gt;&gt;&gt; X.add_variable_ports(\"A\")\n        &gt;&gt;&gt; X._dump_variable_ports()\n        [{'name': 'A', 'description': ''}]\n\n    \"\"\"\n    for port_info in ports:\n        port = self.parse_port_entry(port_info, VariablePort)\n        self._add_variable_port(port)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.ported_objects.PortedObjectWithAssignments","title":"<code>PortedObjectWithAssignments(**kwargs)</code>","text":"<p>               Bases: <code>PortedObject</code></p> <p>Abstract class to hold common functionality of VariablePortedObject and FunctionalPortedObject. Cannot be instantiated directly.</p> Source code in <code>psymple/build/abstract.py</code> <pre><code>def __init__(self, **kwargs):\n    super().__init__(**kwargs)\n    self.assignments = {}\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.VariablePortedObject","title":"<code>VariablePortedObject(name, input_ports=[], variable_ports=[], assignments=[], create_output_ports=True, create_input_ports=True, parsing_locals={}, **kwargs)</code>","text":"<p>               Bases: <code>PortedObjectWithAssignments</code></p> <p>A ported object containing a collection of ODEs (<code>DifferentialAssignment</code> instances).</p> <p>Each ODE is associated to a variable, which may or may not be exposed as a variable port. Symbols on the RHS of the ODE should be either:</p> <ul> <li>Variables defined in this ported object</li> <li>parameters that have corresponding input ports</li> <li>globally defined symbols</li> </ul> PARAMETER DESCRIPTION <code>name</code> <p>a string which must be unique for each <code>PortedObject</code> inside a common <code>CompositePortedObject</code>.</p> <p> TYPE: <code>str</code> </p> <code>input_ports</code> <p>list of input ports to expose. See add_input_ports.</p> <p> TYPE: <code>list[InputPort | dict | tuple | str]</code> DEFAULT: <code>[]</code> </p> <code>variable_ports</code> <p>list of variable ports to expose. See add_variable_ports.</p> <p> TYPE: <code>list[InputPort | dict | str]</code> DEFAULT: <code>[]</code> </p> <code>assignments</code> <p>list of differential assignments (ODEs). See add_variable_assignments</p> <p> TYPE: <code>list[DifferentialAssignment | dict | tuple]</code> DEFAULT: <code>[]</code> </p> <code>create_output_ports</code> <p>if <code>True</code>, automatically create an output port exposing each exposed variable to be read by directed wires. See Notes for more information.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>create_input_ports</code> <p>if <code>True</code>, automatically expose all parameters as input ports. See Notes for more information.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to <code>sympy</code> objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>**kwargs</code> <p>arguments passed to super().init(). No user arguments should be supplied.</p> <p> DEFAULT: <code>{}</code> </p> Notes <ul> <li> <p>By default, each variable (dependent variable of each ODE) is automatically exposed as a     variable port. Alternatively, chosen variables can be exposed by specifying     them in the list variable_ports.</p> </li> <li> <p>By default, each exposed variable will be mirrored in the creation of an output port with     the same name. This output port reads the value of the variable.</p> </li> <li> <p>Parameters listed in input_ports are exposed and can be used in ODE expressions.</p> </li> <li> <p>If <code>create_input_ports=True</code> (default), then each symbol appearing in an ODE which is not a     variable or parameter defined in input_ports is also exposed as a parameter input port. The     created parameter will have no default value, and must be otherwise specified or linked by     a wire in a parent <code>CompositePortedObject</code>.</p> </li> </ul> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    input_ports: list[InputPort | dict | tuple | str] = [],\n    variable_ports: list[InputPort | dict | str] = [],\n    assignments: list[DifferentialAssignment | dict | tuple] = [],\n    create_output_ports: bool = True,\n    create_input_ports: bool = True,\n    parsing_locals: dict = {},\n    **kwargs,\n):\n    \"\"\"\n    Construct a VariablePortedObject.\n\n    Args:\n        name: a string which must be unique for each `PortedObject` inside a common\n            [`CompositePortedObject`][psymple.build.CompositePortedObject].\n        input_ports: list of input ports to expose.\n            See [add_input_ports][psymple.build.abstract.PortedObject.add_input_ports].\n        variable_ports: list of variable ports to expose.\n            See [add_variable_ports][psymple.build.abstract.PortedObject.add_variable_ports].\n        assignments: list of differential assignments (ODEs). See\n            [add_variable_assignments][psymple.build.VariablePortedObject.add_variable_assignments]\n        create_output_ports: if `True`, automatically create an output port exposing each exposed variable\n            to be read by directed wires. See Notes for more information.\n        create_input_ports: if `True`, automatically expose all parameters as input ports. See Notes for more\n            information.\n        parsing_locals: a dictionary mapping strings to `sympy` objects.\n        **kwargs: arguments passed to super().__init__(). No user arguments should be supplied.\n\n    info: Notes\n        - By default, each variable (dependent variable of each ODE) is automatically exposed as a\n            variable port. Alternatively, chosen variables can be exposed by specifying\n            them in the list variable_ports.\n\n        - By default, each exposed variable will be mirrored in the creation of an output port with\n            the same name. This output port reads the value of the variable.\n\n        - Parameters listed in input_ports are exposed and can be used in ODE expressions.\n\n        - If `create_input_ports=True` (default), then each symbol appearing in an ODE which is not a\n            variable or parameter defined in input_ports is also exposed as a parameter input port. The\n            created parameter will have no default value, and must be otherwise specified or linked by\n            a wire in a parent [`CompositePortedObject`][psymple.build.CompositePortedObject].\n    \"\"\"\n    super().__init__(\n        name=name,\n        input_ports=input_ports,\n        variable_ports=variable_ports,\n        parsing_locals=parsing_locals,\n        **kwargs,\n    )\n    # A dict of assignments indexed by the variable name\n    self.internals = {}\n    create_variable_ports = False if variable_ports else True\n    self.add_variable_assignments(\n        *assignments,\n        create_variable_ports=create_variable_ports,\n        create_output_ports=create_output_ports,\n        create_input_ports=create_input_ports,\n    )\n    self.create_input_ports = create_input_ports\n    self.create_output_ports = create_output_ports\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.VariablePortedObject.add_variable_assignments","title":"<code>add_variable_assignments(*assignments, create_variable_ports=True, create_output_ports=True, create_input_ports=True)</code>","text":"<p>Add variable assignments to self.</p> PARAMETER DESCRIPTION <code>*assignments</code> <p>data specifying a <code>DifferentialAssignment</code>. Each entry must be:</p> <ul> <li>an instance of <code>DifferentialAssignment</code>;</li> <li>a <code>dict</code> with keys <code>\"variable\"</code> and <code>\"expression\"</code> which can be passed to     the <code>DifferentialAssignment</code> constructor</li> <li>a <code>tuple</code>, whose first entry is passed to the <code>\"variable\"</code> argument and whose     second is passed to the <code>\"expression\"</code> argument of the <code>DifferentialAssignment</code>     constructor</li> </ul> <p> TYPE: <code>DifferentialAssignment | dict | tuple</code> DEFAULT: <code>()</code> </p> <code>create_variable_ports</code> <p>if <code>True</code>, variable ports exposing the variable of each assignment will automatically be created.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>create_output_ports</code> <p>if <code>True</code>, output ports mirroring each variable port will automatically be created.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>create_input_ports</code> <p>if <code>True</code>, input ports for each free symbol in the expression of each assignment will automatically be created.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if an assignment with the same variable name is already defined in self</p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def add_variable_assignments(\n    self,\n    *assignments: DifferentialAssignment | dict | tuple,\n    create_variable_ports: bool = True,\n    create_output_ports: bool = True,\n    create_input_ports: bool = True,\n):\n    \"\"\"\n    Add variable assignments to self.\n\n    Args:\n        *assignments: data specifying a [`DifferentialAssignment`][psymple.build.assignments.DifferentialAssignment].\n            Each entry must be:\n\n            - an instance of `DifferentialAssignment`;\n            - a `dict` with keys `\"variable\"` and `\"expression\"` which can be passed to\n                the `DifferentialAssignment` constructor\n            - a `tuple`, whose first entry is passed to the `\"variable\"` argument and whose\n                second is passed to the `\"expression\"` argument of the `DifferentialAssignment`\n                constructor\n\n        create_variable_ports: if `True`, variable ports exposing the variable of each assignment\n            will automatically be created.\n        create_output_ports: if `True`, output ports mirroring each variable port will\n            automatically be created.\n        create_input_ports: if `True`, input ports for each free symbol in the expression of each\n            assignment will automatically be created.\n\n    Raises:\n        ValueError: if an assignment with the same variable name is already defined in self\n    \"\"\"\n    for assignment_info in assignments:\n        assignment = self.parse_assignment_entry(\n            assignment_info, DifferentialAssignment\n        )\n        variable_name = assignment.symbol.name\n        if variable_name in self.assignments:\n            raise ValueError(\n                f\"Variable '{variable_name}' in VariablePortedObject '{self.name}' doubly defined.\"\n            )\n        self.assignments[variable_name] = assignment\n        if create_variable_ports:\n            self.add_variable_ports(variable_name)\n        elif variable_name not in self.variable_ports:\n            self.internals[variable_name] = assignment.variable\n\n    if create_output_ports:\n        self.add_output_ports(*self.variable_ports.keys())\n\n    if create_input_ports:\n        # Create input ports for all symbols that are not variables (exposed or internal) or already\n        # specified as input ports.\n        free_symbols = {\n            symb.name\n            for a in self.assignments.values()\n            for symb in a.get_free_symbols()\n        }\n        internal_variables = set(self.internals.keys())\n        variable_ports = set(self.variable_ports.keys())\n        input_ports = set(self.input_ports.keys())\n        undefined_ports = (\n            free_symbols - internal_variables - variable_ports - input_ports\n        )\n        self.add_input_ports(*undefined_ports)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.VariablePortedObject.compile","title":"<code>compile(prefix_names=False, global_symbols=set())</code>","text":"<p>Generate a <code>CompiledPortedObject</code> with:</p> <ul> <li>input ports generated from the input ports of self</li> <li>variable ports exposing the variable and assignment of each assignment     instance of self which have a corresponding variable port of self</li> <li>internal variable assignments for each assignment instance of self     which do not have a corresponding variable port of self</li> <li>identity functional assignments at output ports corresponding to each     exposed variable</li> </ul> PARAMETER DESCRIPTION <code>prefix_names</code> <p>if <code>True</code>, all symbols in self will be prefixed with <code>self.name</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>global_symbols</code> <p>symbols to pass to <code>_assert_no_undefined_symbols</code> method</p> <p> TYPE: <code>set</code> DEFAULT: <code>set()</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def compile(self, prefix_names: bool = False, global_symbols: set = set()):\n    \"\"\"\n    Generate a [`CompiledPortedObject`][psymple.build.ported_objects.CompiledPortedObject] with:\n\n    - input ports generated from the input ports of self\n    - variable ports exposing the variable and assignment of each assignment\n        instance of self which have a corresponding variable port of self\n    - internal variable assignments for each assignment instance of self\n        which do not have a corresponding variable port of self\n    - identity functional assignments at output ports corresponding to each\n        exposed variable\n\n    Args:\n        prefix_names: if `True`, all symbols in self will be prefixed with `self.name`\n        global_symbols: symbols to pass to `_assert_no_undefined_symbols` method\n    \"\"\"\n    self._assert_no_undefined_symbols(global_symbols | self.parsing_locals.keys())\n    compiled = CompiledPortedObject(self.name, self.parsing_locals)\n    for name, assignment in self.assignments.items():\n        if isinstance(assignment, DifferentialAssignment):\n            if name in self.variable_ports:\n                compiled._add_variable_port(\n                    CompiledVariablePort(self.variable_ports[name], assignment)\n                )\n            elif name in self.internals:\n                compiled.internal_variable_assignments[name] = assignment\n\n            if name in self.output_ports:\n                compiled._add_output_port(\n                    CompiledOutputPort(\n                        self.output_ports[name],\n                        FunctionalAssignment(assignment.symbol, assignment.symbol),\n                    )\n                )\n\n    for input_port in self.input_ports.values():\n        compiled._add_input_port(CompiledInputPort(input_port))\n\n    if prefix_names:\n        compiled._sub_prefixed_symbols()\n    return compiled\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.VariablePortedObject.to_data","title":"<code>to_data()</code>","text":"<p>A dismantler method such that every instance X of <code>VariablePortedObject</code> can be recreated by calling <code>X.to_data().to_ported_object()</code></p> RETURNS DESCRIPTION <code>data</code> <p>a data object capturing the data of self</p> <p> TYPE: <code>PortedObjectData</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def to_data(self) -&gt; PortedObjectData:\n    \"\"\"\n    A dismantler method such that every instance X of `VariablePortedObject`\n    can be recreated by calling `X.to_data().to_ported_object()`\n\n    Returns:\n        data: a data object capturing the data of self\n    \"\"\"\n    metadata = {\n        \"name\": self.name,\n        \"type\": \"vpo\",\n    }\n    object_data = {\n        \"input_ports\": self._dump_input_ports(),\n        \"variable_ports\": self._dump_variable_ports(),\n        \"assignments\": self._dump_assignments(),\n        \"create_input_ports\": self.create_input_ports,\n        \"create_output_ports\": self.create_output_ports,\n    }\n    return PortedObjectData(metadata=metadata, object_data=object_data)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.FunctionalPortedObject","title":"<code>FunctionalPortedObject(name, input_ports=[], assignments=[], create_input_ports=True, parsing_locals={}, **kwargs)</code>","text":"<p>               Bases: <code>PortedObjectWithAssignments</code></p> <p>A PortedObject containing a multivariate function.</p> <p>The function is defined by a set of <code>ParameterAssignment</code> instances.</p> <p>The function arguments are the free symbols on the RHS of the assignments, and should be exposed as input ports. The function values are the LHS of the assignments, and are automatically exposed as output ports.</p> <p>Function assignments whose expression references a parameter defined as the function value of another expression are not allowed.</p> PARAMETER DESCRIPTION <code>name</code> <p>a string which must be unique for each <code>PortedObject</code> inside a common <code>CompositePortedObject</code>.</p> <p> TYPE: <code>str</code> </p> <code>input_ports</code> <p>list of input ports to expose. See add_input_ports.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[]</code> </p> <code>assignments</code> <p>list of functional assignments. See add_parameter_assignments.</p> <p> TYPE: <code>list[ParameterAssignment | tuple | dict]</code> DEFAULT: <code>[]</code> </p> <code>create_input_ports</code> <p>if <code>True</code>, automatically expose all parameters as input ports. See Notes for more information.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to <code>sympy</code> objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>**kwargs</code> <p>arguments passed to super().init(). No user arguments should be supplied.</p> <p> DEFAULT: <code>{}</code> </p> Notes <ul> <li> <p>The parameter of every created assignment is automatically exposed as an output port.</p> </li> <li> <p>If <code>create_input_ports=True</code> (default), then each symbol appearing in a function which is not a     parameter defined in input_ports is also exposed as a parameter input port. The     created parameter will have no default value, and must be otherwise specified or linked by     a wire in a parent <code>CompositePortedObject</code>.</p> </li> </ul> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    input_ports: list = [],\n    assignments: list[ParameterAssignment | tuple | dict] = [],\n    create_input_ports: bool = True,\n    parsing_locals: dict = {},\n    **kwargs,\n):\n    \"\"\"\n    Construct a FunctionalPortedObject.\n\n    Args:\n        name: a string which must be unique for each `PortedObject` inside a common\n            [`CompositePortedObject`][psymple.build.CompositePortedObject].\n        input_ports: list of input ports to expose.\n            See [add_input_ports][psymple.build.abstract.PortedObject.add_input_ports].\n        assignments: list of functional assignments. See\n            [add_parameter_assignments][psymple.build.FunctionalPortedObject.add_parameter_assignments].\n        create_input_ports: if `True`, automatically expose all parameters as input ports. See Notes for more\n            information.\n        parsing_locals: a dictionary mapping strings to `sympy` objects.\n        **kwargs: arguments passed to super().__init__(). No user arguments should be supplied.\n\n    info: Notes\n        - The parameter of every created assignment is automatically exposed as an output port.\n\n        - If `create_input_ports=True` (default), then each symbol appearing in a function which is not a\n            parameter defined in input_ports is also exposed as a parameter input port. The\n            created parameter will have no default value, and must be otherwise specified or linked by\n            a wire in a parent [`CompositePortedObject`][psymple.build.CompositePortedObject].\n    \"\"\"\n    # TODO: Functional ported objects should take lists of assignments to a list of output port\n    super().__init__(\n        name=name, input_ports=input_ports, parsing_locals=parsing_locals, **kwargs\n    )\n    self.add_parameter_assignments(\n        *assignments, create_input_ports=create_input_ports\n    )\n    self.create_input_ports = create_input_ports\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.FunctionalPortedObject.add_parameter_assignments","title":"<code>add_parameter_assignments(*assignments, create_input_ports=True)</code>","text":"<p>Add parameter assignments to self.</p> PARAMETER DESCRIPTION <code>*assignments</code> <p>data specifying a <code>ParameterAssignment</code>. Each entry must be:</p> <ul> <li>an instance of <code>ParameterAssignment</code>;</li> <li>a <code>dict</code> with keys <code>\"parameter\"</code> and <code>\"expression\"</code> which can be passed to     the <code>ParameterAssignment</code> constructor</li> <li>a <code>tuple</code>, whose first entry is passed to the <code>\"parameter\"</code> argument and whose     second is passed to the <code>\"expression\"</code> argument of the <code>ParameterAssignment</code>     constructor</li> </ul> <p> TYPE: <code>list[ParameterAssignment | dict | tuple]</code> DEFAULT: <code>()</code> </p> <code>create_input_ports</code> <p>if <code>True</code>, input ports for each free symbol in the expression of each assignment will automatically be created.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if an assignment with the same variable name is already defined in self</p> <code>ValueError</code> <p>if an expression contains a symbol with no corresponding input port</p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def add_parameter_assignments(\n    self,\n    *assignments: list[ParameterAssignment | dict | tuple],\n    create_input_ports: bool = True,\n):\n    \"\"\"\n    Add parameter assignments to self.\n\n    Args:\n        *assignments: data specifying a [`ParameterAssignment`][psymple.build.assignments.ParameterAssignment].\n            Each entry must be:\n\n            - an instance of `ParameterAssignment`;\n            - a `dict` with keys `\"parameter\"` and `\"expression\"` which can be passed to\n                the `ParameterAssignment` constructor\n            - a `tuple`, whose first entry is passed to the `\"parameter\"` argument and whose\n                second is passed to the `\"expression\"` argument of the `ParameterAssignment`\n                constructor\n\n        create_input_ports: if `True`, input ports for each free symbol in the expression of each\n            assignment will automatically be created.\n\n    Raises:\n        ValueError: if an assignment with the same variable name is already defined in self\n        ValueError: if an expression contains a symbol with no corresponding input port\n    \"\"\"\n    for assignment_info in assignments:\n        assignment = self.parse_assignment_entry(\n            assignment_info, FunctionalAssignment\n        )\n        parameter_name = assignment.parameter.name\n        if parameter_name in self.assignments:\n            raise ValueError(\n                f\"Variable '{parameter_name}' in FunctionalPortedObject '{self.name}' doubly defined.\"\n            )\n        free_symbols = assignment.get_free_symbols()\n        for symbol in free_symbols:\n            name = symbol.name\n            if name not in self.input_ports:\n                if create_input_ports:\n                    self.add_input_ports(name)\n                else:\n                    raise ValueError(\n                        f\"Expression contains symbol {name} but there is no \"\n                        \"corresponding input port.\"\n                    )\n        self.assignments[parameter_name] = assignment\n        self.output_ports[parameter_name] = OutputPort(parameter_name)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.FunctionalPortedObject.compile","title":"<code>compile(prefix_names=False)</code>","text":"<p>Generate a <code>CompiledPortedObject</code> with:</p> <ul> <li>input ports generated from input ports of self</li> <li>output ports exposing the parameter and assignment of each assignment     instance of self</li> </ul> PARAMETER DESCRIPTION <code>prefix_names</code> <p>if <code>True</code>, all symbols in self will be prefixed with <code>self.name</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def compile(self, prefix_names: bool = False):\n    \"\"\"\n    Generate a [`CompiledPortedObject`][psymple.build.ported_objects.CompiledPortedObject] with:\n\n    - input ports generated from input ports of self\n    - output ports exposing the parameter and assignment of each assignment\n        instance of self\n\n    Args:\n        prefix_names: if `True`, all symbols in self will be prefixed with `self.name`\n    \"\"\"\n    compiled = CompiledPortedObject(self.name, self.parsing_locals)\n    # Pass input ports of self through to input ports of compiled object\n    for name, input_port in self.input_ports.items():\n        compiled._add_input_port(CompiledInputPort(input_port))\n    # Create an output port of compiled holding each assignment of self\n    for name, output_port in self.output_ports.items():\n        assignment = self.assignments[name]\n        compiled._add_output_port(CompiledOutputPort(output_port, assignment))\n    # Prefix names  for objects compiled as children\n    if prefix_names:\n        compiled._sub_prefixed_symbols()\n    return compiled\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.FunctionalPortedObject.to_data","title":"<code>to_data()</code>","text":"<p>A dismantler method such that every instance X of <code>VariablePortedObject</code> can be recreated by calling <code>X.to_data().to_ported_object()</code></p> RETURNS DESCRIPTION <code>data</code> <p>a data object capturing the data of self</p> <p> TYPE: <code>PortedObjectData</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def to_data(self) -&gt; PortedObjectData:\n    \"\"\"\n    A dismantler method such that every instance X of `VariablePortedObject`\n    can be recreated by calling `X.to_data().to_ported_object()`\n\n    Returns:\n        data: a data object capturing the data of self\n    \"\"\"\n    metadata = {\n        \"name\": self.name,\n        \"type\": \"fpo\",\n    }\n    object_data = {\n        \"input_ports\": self._dump_input_ports(),\n        \"assignments\": self._dump_assignments(),\n        \"create_input_ports\": self.create_input_ports,\n    }\n    return PortedObjectData(metadata=metadata, object_data=object_data)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject","title":"<code>CompositePortedObject(name, children=[], input_ports=[], output_ports=[], variable_ports=[], variable_wires=[], directed_wires=[], parsing_locals={}, **kwargs)</code>","text":"<p>               Bases: <code>PortedObject</code></p> <p>A ported object containing other ported object instances whose ports are connected by directed wires and variable wires.</p>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject--directed-wires","title":"Directed wires","text":"<p>Directed wires connect:</p> <ul> <li>an input port of self to input ports of children, or,</li> <li>an output port of a child to input ports of children and/or upto one output port of self, or,</li> <li>a variable port of a child to input ports of children.</li> </ul> <p>These wires capture functional composition. In the following example, a  <code>CompositePortedObject</code> instance <code>X</code> contains <code>FunctionalPortedObject</code> instances <code>A</code> and <code>B</code>. Object <code>A</code> specifies the assignment \\( x = f(y) \\) and <code>B</code> specifies the assignment \\( r = g(u,v) \\). Connecting output port <code>x</code> of <code>A</code> (accessed by <code>\"A.x\"</code>) to input port <code>u</code> of <code>B</code> (accessed by <code>\"B.u\"</code>) with a directed wire represents the composite assignment \\( r = g(f(y), v) \\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from psymple.build import FunctionalPortedObject, CompositePortedObject\n&gt;&gt;&gt; A = FunctionalPortedObject(name=\"A\", assignments=[(\"x\", \"f(y)\")])\n&gt;&gt;&gt; B = FunctionalPortedObject(name=\"B\", assignments=[(\"y\", \"g(u,v)\")])\n&gt;&gt;&gt; X = CompositePortedObject(name=\"X\", children=[A,B], directed_wires=[(\"A.x\", \"B.u\")])\n</code></pre> <p>See <code>add_wires</code> for the syntax to specify directed wires.</p>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject--variable-wires","title":"Variable wires","text":"<p>Variable wires connect variable ports of children to upto one variable port of self.</p> <p>These wires capture ODE aggregation:</p> ODE aggregation <p>The aggregation of the ODEs \\( dx/dt = f(x,t,a) \\) and \\( dy/dt = g(y,t,b) \\), identifying \\( (x,y) \\longrightarrow z \\), is the ODE \\( dz/dt = f(z,t,a) + g(z,t,b) \\).</p> <p>In the following example, a  <code>CompositePortedObject</code> instance <code>X</code> contains <code>VariablePortedObject</code> instances <code>A</code> and <code>B</code>. Object <code>A</code> specifies the ODE \\( dx/dt = f(x,t,a) \\) and <code>B</code> specifies the ODE \\( dy/dt = g(y,t,b) \\). Aggregating variable port <code>x</code> of <code>A</code> (accessed by <code>\"A.x\"</code>) and variable port <code>y</code> of <code>B</code> (accessed by <code>\"B.y\"</code>) and exposing at variable port <code>z</code> of <code>X</code> (identifying \\( (x,y) \\longrightarrow z \\)) represents the ODE \\( dz/dt = f(z,t,a) + g(z,t,b) \\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from psymple.build import FunctionalPortedObject, CompositePortedObject\n&gt;&gt;&gt; A = FunctionalPortedObject(name=\"A\", assignments=[(\"x\", \"f(x,t,a)\")])\n&gt;&gt;&gt; B = FunctionalPortedObject(name=\"B\", assignments=[(\"y\", \"g(y,t,b)\")])\n&gt;&gt;&gt; X = CompositePortedObject(name=\"X\", children=[A,B], variable_ports = [\"z\"], variable_wires=[([\"A.x\", \"B.u\"], \"z\")])\n</code></pre> <p>See <code>add_wires</code> for the syntax to specify directed wires.</p> Requirements <ul> <li> <p>Every input port of self should be the source of at least one directed wire</p> </li> <li> <p>Every output port of self must be the destination of exactly one directed wire</p> </li> <li> <p>Every variable port of self must be the destination of at most one variable wire</p> </li> <li> <p>Every input port of a child must either have a default value or a     directed wire connected to it</p> </li> <li> <p>Every output port of a child should have a directed wire going out of it</p> </li> <li> <p>Every variable port of a child should have a variable wire connected to it</p> </li> <li> <p>The directed wires should have no cycles (when contracting child ported     objects into nodes of a graph)</p> </li> </ul> PARAMETER DESCRIPTION <code>name</code> <p>a string which must be unique for each <code>PortedObject</code> inside a common <code>CompositePortedObject</code>.</p> <p> TYPE: <code>str</code> </p> <code>children</code> <p>list of children to add. See add_children.</p> <p> TYPE: <code>list[PortedObject | PortedObjectData]</code> DEFAULT: <code>[]</code> </p> <code>input_ports</code> <p>list of input ports to expose. See add_input_ports.</p> <p> TYPE: <code>list[InputPort | dict | tuple | str]</code> DEFAULT: <code>[]</code> </p> <code>output_ports</code> <p>list of output ports to expose. See add_output_ports.</p> <p> TYPE: <code>list[OutputPort | dict | str]</code> DEFAULT: <code>[]</code> </p> <code>variable_ports</code> <p>list of variable ports to expose. See add_variable_ports.</p> <p> TYPE: <code>list[VariablePort | dict | str]</code> DEFAULT: <code>[]</code> </p> <code>variable_wires</code> <p>list of variable wires to create. See add_wires.</p> <p> TYPE: <code>list[dict | tuple]</code> DEFAULT: <code>[]</code> </p> <code>directed_wires</code> <p>list of directed wires to create. See add_wires.</p> <p> TYPE: <code>list[dict | tuple]</code> DEFAULT: <code>[]</code> </p> <code>parsing_locals</code> <p>a dictionary mapping strings to <code>sympy</code> objects.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>**kwargs</code> <p>arguments passed to super().init(). No user arguments should be supplied.</p> <p> DEFAULT: <code>{}</code> </p> Note <p>There is no automatic creation of ports in a <code>CompositePortedObject</code></p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    children: list[PortedObject | PortedObjectData] = [],\n    input_ports: list[InputPort | dict | tuple | str] = [],\n    output_ports: list[OutputPort | dict | str] = [],\n    variable_ports: list[VariablePort | dict | str] = [],\n    variable_wires: list[dict | tuple] = [],\n    directed_wires: list[dict | tuple] = [],\n    parsing_locals: dict = {},\n    **kwargs,\n):\n    \"\"\"\n    Construct a CompositePortedObject.\n\n    Args:\n        name: a string which must be unique for each `PortedObject` inside a common\n            [`CompositePortedObject`][psymple.build.CompositePortedObject].\n        children: list of children to add.\n            See [add_children][psymple.build.CompositePortedObject.add_children].\n        input_ports: list of input ports to expose.\n            See [add_input_ports][psymple.build.abstract.PortedObject.add_input_ports].\n        output_ports: list of output ports to expose.\n            See [add_output_ports][psymple.build.abstract.PortedObject.add_input_ports].\n        variable_ports: list of variable ports to expose.\n            See [add_variable_ports][psymple.build.abstract.PortedObject.add_variable_ports].\n        variable_wires: list of variable wires to create. See\n            [add_wires][psymple.build.CompositePortedObject.add_wires].\n        directed_wires: list of directed wires to create. See\n            [add_wires][psymple.build.CompositePortedObject.add_wires].\n        parsing_locals: a dictionary mapping strings to `sympy` objects.\n        **kwargs: arguments passed to super().__init__(). No user arguments should be supplied.\n\n    info: Note\n        There is no automatic creation of ports in a `CompositePortedObject`\n    \"\"\"\n    super().__init__(\n        name=name,\n        input_ports=input_ports,\n        output_ports=output_ports,\n        variable_ports=variable_ports,\n        parsing_locals=parsing_locals,\n        **kwargs,\n    )\n    self.children = {}\n    self.variable_aggregation_wiring = []\n    self.directed_wires = []\n    self.add_children(*children)\n    self.add_wires(variable_wires=variable_wires, directed_wires=directed_wires)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject.add_children","title":"<code>add_children(*children)</code>","text":"<p>Add children to <code>self</code>. A child is a <code>PortedObject</code> instance whose ports and assignments become available to <code>self</code>.</p> PARAMETER DESCRIPTION <code>*children</code> <p>instance of <code>PortedObject</code> or <code>PortedObjectData</code> specifying a ported object. Entries can be a mixture of types.</p> <p> TYPE: <code>PortedObjectData | PortedObject</code> DEFAULT: <code>()</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def add_children(self, *children: PortedObjectData | PortedObject):\n    \"\"\"\n    Add children to `self`. A child is a `PortedObject` instance whose ports and assignments\n    become available to `self`.\n\n    Args:\n        *children: instance of `PortedObject` or `PortedObjectData` specifying a\n            ported object. Entries can be a mixture of types.\n    \"\"\"\n    for data in children:\n        # Attempt to coerce dictionary into PortedObjectData\n        if isinstance(data, dict):\n            if not type(data) == PortedObjectData:\n                data = PortedObjectData(**data)\n            self._build_child(data)\n        elif isinstance(data, PortedObject):\n            self._add_child(data)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject.add_directed_wire","title":"<code>add_directed_wire(source_name, destination_names)</code>","text":"<p>Add a directed wire to self.</p> PARAMETER DESCRIPTION <code>source_name</code> <p>a string identifying the source port</p> <p> TYPE: <code>str</code> </p> <code>destination_names</code> <p>a string or a list of strings identifying destination port(s)</p> <p> TYPE: <code>str | list[str]</code> </p> RAISES DESCRIPTION <code>WiringError</code> <p>if the provided ports cannot be found or are of incorrect type.</p> Note <p>It is recommended to use the add_wires method for additional entry options and to add multiple wires at the same time.</p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def add_directed_wire(self, source_name: str, destination_names: str | list[str]):\n    \"\"\"\n    Add a directed wire to self.\n\n    Args:\n        source_name: a string identifying the source port\n        destination_names: a string or a list of strings identifying destination port(s)\n\n    Raises:\n        WiringError: if the provided ports cannot be found or are of incorrect type.\n\n    info: Note\n        It is recommended to use the [add_wires][psymple.build.CompositePortedObject.add_wires]\n        method for additional entry options and to add multiple wires at the same time.\n    \"\"\"\n    source_port = self._get_port_by_name(source_name, \"parameter\")\n    error_text = (\n        f\"directed wire from {source_name} to {destination_names} in {self.name}\"\n    )\n    if source_port is None:\n        raise WiringError(\n            f\"Error adding {error_text}. \"\n            f\"Source port '{source_name}' does not exist.\"\n        )\n    if (\n        source_name in self.output_ports\n        or type(source_port) is VariablePort\n        or (source_name not in self.input_ports and type(source_port) is InputPort)\n    ):\n        # Source must be: own input, or child output\n        raise WiringError(\n            f\"Error adding {error_text}. Source port '{source_name}' \"\n            \"must be an input port or a child output port.\"\n        )\n    # If a singular destination is specified, coerce it into a list\n    if isinstance(destination_names, str):\n        destination_names = [destination_names]\n    for destination_name in destination_names:\n        destination_port = self._get_port_by_name(destination_name, \"parameter\")\n        if destination_port is None:\n            raise WiringError(\n                f\"Error adding {error_text}. \"\n                f\"Destination port '{destination_name}' does not exist.\"\n            )\n        if (\n            destination_name in self.input_ports\n            or type(source_port) is VariablePort\n            or (\n                destination_name not in self.output_ports\n                and type(destination_port) is OutputPort\n            )\n        ):\n            # Destination must be: own output, or child input\n            raise WiringError(\n                f\"Error adding {error_text}. \"\n                f\"Destination port '{destination_name}' must be \"\n                \"an output port or a child input port.\"\n            )\n\n    wire = DirectedWire(source_name, destination_names)\n    self.directed_wires.append(wire)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject.add_variable_wire","title":"<code>add_variable_wire(child_ports, parent_port=None, output_name=None)</code>","text":"<p>Add a variable wire to self.</p> PARAMETER DESCRIPTION <code>child_ports</code> <p>a list of strings identifying variable ports to aggregate</p> <p> TYPE: <code>list[str]</code> </p> <code>parent_port</code> <p>a string identifying the parent variable port of self to identify with</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>output_name</code> <p>a string identifying the aggregation internally if a parent port is not specified.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>WiringError</code> <p>if the provided ports cannot be found or are of incorrect type.</p> Note <p>It is recommended to use the add_wires method for additional entry options and to add multiple wires at the same time.</p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def add_variable_wire(\n    self,\n    child_ports: list[str],\n    parent_port: str = None,\n    output_name: str = None,\n):\n    \"\"\"\n    Add a variable wire to self.\n\n    Args:\n        child_ports: a list of strings identifying variable ports to aggregate\n        parent_port: a string identifying the parent variable port of self to identify with\n        output_name: a string identifying the aggregation internally if a parent port\n            is not specified.\n\n    Raises:\n        WiringError: if the provided ports cannot be found or are of incorrect type.\n\n    info: Note\n        It is recommended to use the [add_wires][psymple.build.CompositePortedObject.add_wires]\n        method for additional entry options and to add multiple wires at the same time.\n    \"\"\"\n    error_text = f\"variable wire with {f'parent_port {parent_port}' if parent_port else f'output_name {output_name}'} and children {child_ports} in {self.name}\"\n    if parent_port is not None:\n        port = self._get_port_by_name(parent_port, \"variable\")\n        if (\n            port is None\n            or not type(port) is VariablePort\n            or not self._is_own_port(parent_port)\n        ):\n            WiringError(\n                f\"Error adding {error_text}. \"\n                f\"Parent port '{parent_port}' must be a variable port \"\n                \"of the ported object itself.\"\n            )\n    # Child ports should be ports of children\n    for child_port in child_ports:\n        port = self._get_port_by_name(child_port, \"variable\")\n        if (\n            port is None\n            or not type(port) is VariablePort\n            or self._is_own_port(child_port)\n        ):\n            WiringError(\n                f\"Error adding {error_text}. \"\n                f\"Child port '{child_port}' must be a variable port of a child.\"\n            )\n    wiring = VariableAggregationWiring(child_ports, parent_port, output_name)\n    self.variable_aggregation_wiring.append(wiring)\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject.add_wires","title":"<code>add_wires(variable_wires=[], directed_wires=[])</code>","text":"<p>Add wires to self.</p> <p>Variable wires aggregate a set of child variable ports, and either</p> <ul> <li>expose the result as a variable port of self, or,</li> <li>store the result internally.</li> </ul> <p>Either a parent port or internal name must be provided. Specifying a parent port will override the internal name.</p> <p>Directed wires connect</p> <ul> <li>an input port of self to input ports of children, or,</li> <li>an output port of a child to input ports of children and/or upto one output port of self, or,</li> <li>a variable port of a child to input ports of children.</li> </ul> PARAMETER DESCRIPTION <code>variable_wires</code> <p>a list of either:</p> <ul> <li>a dictionary specifying <code>\"child_ports\"</code> (<code>list[str]</code>), and either <code>\"parent_port\"</code> (<code>str</code>),     or <code>\"output_name\"</code> (<code>str</code>);</li> <li>a tuple which maps to the above dictionary, which must either be of the form     <code>(child_ports, parent_port)</code> or <code>(child_ports, None, output_name)</code>.</li> </ul> <p> TYPE: <code>list</code> DEFAULT: <code>[]</code> </p> <code>directed_wires</code> <p>a list of either:</p> <ul> <li>a dictionary specifying <code>\"source\"</code> (<code>str</code>) and either <code>\"destinations\"</code> (<code>list[str]</code>)     or <code>\"destination\"</code> (<code>str</code>);</li> <li>a tuple, which maps to the above dictionary, which must be of the form     <code>(source, destinations)</code> or <code>(source, destination)</code>.</li> </ul> <p> TYPE: <code>list</code> DEFAULT: <code>[]</code> </p> RAISES DESCRIPTION <code>ValidationError</code> <p>if the provided data cannot be parsed correctly.</p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def add_wires(self, variable_wires: list = [], directed_wires: list = []):\n    \"\"\"\n    Add wires to self.\n\n    Variable wires aggregate a set of child variable ports, and either\n\n    - expose the result as a variable port of self, or,\n    - store the result internally.\n\n    Either a parent port or internal name must be provided. Specifying a parent port will\n    override the internal name.\n\n    Directed wires connect\n\n    - an input port of self to input ports of children, or,\n    - an output port of a child to input ports of children and/or upto one output port of self, or,\n    - a variable port of a child to input ports of children.\n\n    Args:\n        variable_wires: a list of either:\n\n            - a dictionary specifying `\"child_ports\"` (`list[str]`), and either `\"parent_port\"` (`str`),\n                or `\"output_name\"` (`str`);\n            - a tuple which maps to the above dictionary, which must either be of the form\n                `(child_ports, parent_port)` or `(child_ports, None, output_name)`.\n\n        directed_wires: a list of either:\n\n            - a dictionary specifying `\"source\"` (`str`) and either `\"destinations\"` (`list[str]`)\n                or `\"destination\"` (`str`);\n            - a tuple, which maps to the above dictionary, which must be of the form\n                `(source, destinations)` or `(source, destination)`.\n\n    Raises:\n        ValidationError: if the provided data cannot be parsed correctly.\n    \"\"\"\n    for wire_info in variable_wires:\n        if isinstance(wire_info, dict):\n            keys = wire_info.keys()\n            if \"child_ports\" in keys and (\n                \"parent_port\" in keys or \"output_name\" in keys\n            ):\n                self.add_variable_wire(**wire_info)\n            else:\n                raise ValidationError(\n                    f\"The dictionary {wire_info} must at least specify keys \"\n                    f'\"child_ports\" and either \"parent_port\" or \"output_name.'\n                )\n        elif isinstance(wire_info, tuple):\n            self.add_variable_wire(\n                child_ports=wire_info[0],\n                parent_port=wire_info[1] if len(wire_info) &gt;= 2 else None,\n                output_name=wire_info[2] if len(wire_info) == 3 else None,\n            )\n        else:\n            raise ValidationError(\n                f\"The information {wire_info} is not a dictionary or tuple\"\n            )\n\n    for wire_info in directed_wires:\n        if isinstance(wire_info, dict):\n            keys = wire_info.keys()\n            if keys == {\"source\", \"destinations\"} or keys == {\n                \"source\",\n                \"destination\",\n            }:\n                self.add_directed_wire(*wire_info.values())\n            else:\n                raise ValidationError(\n                    f'The dictionary {wire_info} must contain keys \"source\" and either \"destination\" or \"destinations\".'\n                )\n        elif isinstance(wire_info, tuple):\n            self.add_directed_wire(*wire_info)\n        else:\n            raise ValidationError(\n                f\"The element {wire_info} is not a dictionary or tuple\"\n            )\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject.compile","title":"<code>compile(prefix_names=False)</code>","text":"<p>Generate a <code>CompiledPortedObject</code> with:</p> <ul> <li>input ports generated from input ports of self</li> <li>output ports generated from output ports of self, with assignments exposed by directed wires</li> <li>variable ports generated from variable ports of self, with assignments exposed by variable wires</li> <li>internal variable assignments generated from variable assignments of children not exposed to     variable ports</li> <li>internal parameter assignments generated from parameter assignments of children not exposed to     output ports</li> </ul> PARAMETER DESCRIPTION <code>prefix_names</code> <p>if <code>True</code>, all symbols in self will be prefixed with <code>self.name</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def compile(self, prefix_names: bool = False):\n    \"\"\"\n    Generate a [`CompiledPortedObject`][psymple.build.ported_objects.CompiledPortedObject] with:\n\n    - input ports generated from input ports of self\n    - output ports generated from output ports of self, with assignments exposed by directed wires\n    - variable ports generated from variable ports of self, with assignments exposed by variable wires\n    - internal variable assignments generated from variable assignments of children not exposed to\n        variable ports\n    - internal parameter assignments generated from parameter assignments of children not exposed to\n        output ports\n\n    Args:\n        prefix_names: if `True`, all symbols in self will be prefixed with `self.name`\n    \"\"\"\n    # Approch:\n    #   - Compile each child of self recursively\n    #   - Compile input ports of self\n    #   - Collect input ports, variable ports and internal assignments of children\n    #   - Process directed wires, producing compiled output ports, symbol identifications,\n    #       or internal parameter assignments, as neccesary\n    #   - Process variable wires, performing variable aggregations and producing compiled\n    #       variable ports or internal variable assignments, as necessary\n    #   - Perform any symbol identifications\n    #   - Perform consistency remapping and prefixing inside self, as necessary\n\n    internal_symbol_identifications = []\n    output_symbol_identifications = []\n    compiled = CompiledPortedObject(self.name, self.parsing_locals)\n    compiled.children = {\n        name: child.compile(prefix_names=True)\n        for name, child in self.children.items()\n    }\n\n    # Compile own input ports. Not much happening for input ports.\n    for name, input_port in self.input_ports.items():\n        # compiled.input_ports[name] = CompiledInputPort(input_port)\n        compiled._add_input_port(CompiledInputPort(input_port))\n\n    for name, variable_port in self.variable_ports.items():\n        compiled._add_variable_port(CompiledVariablePort(variable_port, 0))\n\n    # For each child input port, we have to ensure it's\n    # connected or has a default value\n\n    unconnected_child_input_ports = {}\n    unconnected_child_variable_ports = {}\n    for child_name, child in compiled.children.items():\n        # Collect all child input ports\n        for name, port in child.input_ports.items():\n            new_name = HIERARCHY_SEPARATOR.join([child_name, name])\n            unconnected_child_input_ports[new_name] = port\n        # Collect all child variable ports\n        for name, port in child.variable_ports.items():\n            new_name = HIERARCHY_SEPARATOR.join([child_name, name])\n            unconnected_child_variable_ports[new_name] = port\n        # Pass forward internal variable/parameter assignments. Their keys are remapped\n        # at this point to prevent duplication.\n        compiled.internal_variable_assignments.update(\n            {\n                assg.name: assg\n                for assg in child.internal_variable_assignments.values()\n            }\n        )\n        compiled.internal_parameter_assignments.update(\n            {\n                assg.name: assg\n                for assg in child.internal_parameter_assignments.values()\n            }\n        )\n        # Pass forward assignments from output ports. Assignments may later be exposed\n        # at an output port by a directed wire.\n        # TODO: Unconnected output ports are an indication that something may be wrong\n        # If an output port is not connected, we could consider discarding it\n        for name, port in child.output_ports.items():\n            if assg := port.assignment:\n                compiled.internal_parameter_assignments[assg.name] = assg\n\n    # Process directed wires.\n    for wire in self.directed_wires:\n\n        # Directed wires connect:\n        # - an input port to child input ports, or;\n        # - a child output port to child input ports and at most one output port.\n        # We take cases on the number of output ports a directed wire connects to.\n        outputs = [\n            port for port in self.output_ports if port in wire.destination_ports\n        ]\n        num_outputs = len(outputs)\n        if num_outputs &gt; 1:\n            # No wire can point to more than one output port\n            raise WiringError(\n                f\"Incorrect wiring in '{self.name}'. \"\n                f\"The directed wire from port {wire.source_port} to {wire.destination_ports}\"\n                \"is connected to two different output ports. \"\n            )\n        elif num_outputs == 1:\n            # A wire ending at an output port can only start at a child output port.\n            source = compiled._get_port_by_name(wire.source_port, \"parameter\")\n            if type(source) is not CompiledOutputPort:\n                raise WiringError(\n                    f\"Incorrect wiring in '{self.name}'. \"\n                    f\"The directed wire from port {wire.source_port} to {wire.destination_ports}\"\n                    f\"starts at {wire.source_port}, which is not a child output port.\"\n                )\n\n        source = compiled._get_port_by_name(wire.source_port, \"parameter\")\n        # Now we perform the identifications. In the process we check which child ports\n        # don't have an incoming wire using unconnected_child_input_ports.\n        for destination_port in wire.destination_ports:\n            if destination_port in unconnected_child_input_ports:\n                # Goes from own input or child output port to child input port.\n                # In all of these cases, the ports have been pre-compiled\n                destination = compiled._get_port_by_name(\n                    destination_port, \"parameter\"\n                )\n                assert type(destination) is CompiledInputPort\n\n                # Substitute the destination symbol for the wire symbol\n                symb_id = SymbolIdentification(source.symbol, destination.symbol)\n                internal_symbol_identifications.append(symb_id)\n                unconnected_child_input_ports.pop(destination_port)\n            elif destination_port in self.output_ports:\n                # We can only be in this case if the source is a child output port,\n                # which has already been compiled\n                source = compiled._get_port_by_name(wire.source_port, \"parameter\")\n                destination = self._get_port_by_name(destination_port, \"parameter\")\n                assert type(destination) is OutputPort\n\n                # If the source port is an output port, pass the parameter assignment\n                # which was at the child output port through to the destination port,\n                # and identify the source symbol to the destination symbol.\n                if type(source) is CompiledOutputPort:\n                    # Substitute the source symbol for the output port symbol\n                    symb_id = SymbolIdentification(\n                        destination.symbol, source.symbol\n                    )\n                    output_symbol_identifications.append(symb_id)\n\n                    # Pass forward the assignment at source, currently stored as an\n                    # internal parameter assignment, to the output port.\n                    source_assg = compiled.internal_parameter_assignments.pop(\n                        source.name\n                    )\n                    compiled._add_output_port(\n                        CompiledOutputPort(\n                            destination,\n                            source_assg,\n                        )\n                    )\n            else:\n                raise WiringError(\n                    f\"Incorrect wiring in '{self.name}'. \"\n                    \"Directed wire destination should be output port \"\n                    f\"or child input port but is {destination_port}\"\n                )\n\n    # Find unconnected child input ports and check for default values\n    bad_input_ports = []\n    for name, port in unconnected_child_input_ports.items():\n        if port.default_value is None:\n            bad_input_ports.append(name)\n        else:\n            # Initialize their parameters with default values\n            assg = DefaultParameterAssignment(\n                port.symbol, port.default_value, self.parsing_locals\n            )\n            compiled.internal_parameter_assignments[name] = assg\n    if bad_input_ports:\n        raise WiringError(\n            f\"Incorrect wiring in '{self.name}'. \"\n            \"The following child input ports are unconnected \"\n            f\"and have no default value: {bad_input_ports}\"\n        )\n\n    # Process variable aggregation wiring\n    # TODO: Warn if there is a variable port that is not connected to children\n    compiled.variable_ports = {}\n    for wiring in self.variable_aggregation_wiring:\n        # Collect child ports\n        child_ports = []\n        for port_name in wiring.child_ports:\n            unconnected_child_variable_ports.pop(port_name)\n            port = compiled._get_port_by_name(port_name, \"variable\")\n            child_ports.append(port)\n\n        if wiring.parent_port is not None:\n            new_var_name = wiring.parent_port\n        elif wiring.output_name is not None:\n            new_var_name = wiring.output_name\n        else:\n            raise WiringError(\n                f\"For VariableAggregationWiring, either parent_port \"\n                \"or output_name need to be provided\"\n            )\n        # Combine RHSs of each child variable, and set child variables equal\n        assg = DifferentialAssignment(new_var_name, \"0\")\n        for child in child_ports:\n            assg.combine(child.assignment)\n            assert isinstance(child.assignment.symbol, sym.Symbol)\n            internal_symbol_identifications.append(\n                SymbolIdentification(assg.symbol, child.assignment.symbol)\n            )\n        if wiring.parent_port is not None:\n            parent = self._get_port_by_name(wiring.parent_port, \"variable\")\n            new_port = CompiledVariablePort(parent, assg)\n            compiled._add_variable_port(new_port)\n            # compiled.variable_ports[parent.name] = new_port\n        else:\n            compiled.internal_variable_assignments[new_var_name] = assg\n\n    # Make unconnected child ports into unexposed variables\n    for name, port in unconnected_child_variable_ports.items():\n        compiled.internal_variable_assignments[name] = port.assignment\n\n    compiled._sub_symbol_identifications(\n        internal_symbol_identifications, output_symbol_identifications\n    )\n\n    # Align the dictionary keys with the names of the symbols\n    # whose assignments the dictionary is storing.\n    # This has to happen after all the wiring compilation,\n    # because the wires refer to the child + port name within the child,\n    # so the child name cannot be part of the dictionary key while\n    # the wiring is compiled. For internal assignments pulled up from\n    # children, this remapping has already happened and those dictionaries\n    # are unaffected.\n    compiled._remap_dict_keys()\n\n    if prefix_names:\n        # After this, all variables/parameters appearing everywhere\n        # are prefixed by the name of the ported object.\n        # This, however, does not apply to the dictionary keys,\n        # see above for the reasoning\n        compiled._sub_prefixed_symbols()\n\n    return compiled\n</code></pre>"},{"location":"reference/build/ported_objects/#psymple.build.CompositePortedObject.to_data","title":"<code>to_data()</code>","text":"<p>A dismantler method such that every instance X of <code>CompositePortedObject</code> can be recreated by calling <code>X.to_data().to_ported_object()</code></p> RETURNS DESCRIPTION <code>data</code> <p>a data object capturing the data of self</p> <p> TYPE: <code>PortedObjectData</code> </p> Source code in <code>psymple/build/ported_objects.py</code> <pre><code>def to_data(self) -&gt; PortedObjectData:\n    \"\"\"\n    A dismantler method such that every instance X of `CompositePortedObject`\n    can be recreated by calling `X.to_data().to_ported_object()`\n\n    Returns:\n        data: a data object capturing the data of self\n    \"\"\"\n    metadata = {\n        \"name\": self.name,\n        \"type\": \"cpo\",\n    }\n    object_data = {\n        \"children\": self._dump_children(),\n        \"input_ports\": self._dump_input_ports(),\n        \"output_ports\": self._dump_output_ports(),\n        \"variable_ports\": self._dump_variable_ports(),\n        \"directed_wires\": self._dump_directed_wires(),\n        \"variable_wires\": self._dump_variable_wires(),\n    }\n    return PortedObjectData(metadata=metadata, object_data=object_data)\n</code></pre>"},{"location":"reference/build/ports/","title":"Ports","text":""},{"location":"reference/build/ports/#psymple.build.ports.Port","title":"<code>Port(name, description='')</code>","text":"<p>Base class for all ports. </p> <p>Ports are key to the definition of ported objects. A ported object can be thought of as a container for some information. A port exposes some of that information, labeled by an identifier, to the exterior of that object.</p> <p>Different implementations of ports expose different information in different ways.</p> Warning <p>The <code>Port</code> class should not be instantiated directly.</p> Note <p>The name of a port uniquely determines its symbol. The symbol only has relevance  in two cases:    </p> <ul> <li> <p>Input port symbols for <code>VariablePortedObject</code> and <code>FunctionalPortedObject</code>      instances. In this case, the symbol may appear in expressions defined within      those objects, and input values will be substituted into it.</p> </li> <li> <p>Variable port symbols when the variable port is not connected on the outside.      This symbol will then become globally associated to the variable that is     simulated in the system.</p> </li> </ul> PARAMETER DESCRIPTION <code>name</code> <p>the identifier of a port associated to a <code>PortedObject</code></p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>a description of the contents of a port </p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if an invalid name is given. By default, this is any string containing a period <code>\".\"</code>.</p> Source code in <code>psymple/build/ports.py</code> <pre><code>def __init__(self, name: str , description: str = \"\"):\n    \"\"\"\n    Initialise a Port.\n\n    Args:\n        name: the identifier of a port associated to a [`PortedObject`][psymple.build.abstract.PortedObject]\n        description: a description of the contents of a port \n\n    Raises:\n        ValueError: if an invalid name is given. By default, this is any string containing a period `\".\"`.\n    \"\"\"\n    if HIERARCHY_SEPARATOR in name:\n        raise ValueError(\n            f\"Port '{name}': Port names must not contain '{HIERARCHY_SEPARATOR}'.\"\n        )\n    self.name = name\n    self.description = description\n</code></pre>"},{"location":"reference/build/ports/#psymple.build.ports.InputPort","title":"<code>InputPort(name, description='', default_value=None)</code>","text":"<p>               Bases: <code>Port</code></p> <p>An input port is a port exposing a system parameter which can be provided a value.</p> Source code in <code>psymple/build/ports.py</code> <pre><code>def __init__(self, name, description=\"\", default_value=None):\n    super().__init__(name, description)\n    self.default_value = default_value\n</code></pre>"},{"location":"reference/build/ports/#psymple.build.ports.OutputPort","title":"<code>OutputPort(name, description='')</code>","text":"<p>               Bases: <code>Port</code></p> <p>An output port is a port exposing a system parameter which can be read from.</p> Source code in <code>psymple/build/ports.py</code> <pre><code>def __init__(self, name: str , description: str = \"\"):\n    \"\"\"\n    Initialise a Port.\n\n    Args:\n        name: the identifier of a port associated to a [`PortedObject`][psymple.build.abstract.PortedObject]\n        description: a description of the contents of a port \n\n    Raises:\n        ValueError: if an invalid name is given. By default, this is any string containing a period `\".\"`.\n    \"\"\"\n    if HIERARCHY_SEPARATOR in name:\n        raise ValueError(\n            f\"Port '{name}': Port names must not contain '{HIERARCHY_SEPARATOR}'.\"\n        )\n    self.name = name\n    self.description = description\n</code></pre>"},{"location":"reference/build/ports/#psymple.build.ports.VariablePort","title":"<code>VariablePort(name, description='')</code>","text":"<p>               Bases: <code>Port</code></p> <p>A variable port is a port exposing a system variable.</p> Source code in <code>psymple/build/ports.py</code> <pre><code>def __init__(self, name: str , description: str = \"\"):\n    \"\"\"\n    Initialise a Port.\n\n    Args:\n        name: the identifier of a port associated to a [`PortedObject`][psymple.build.abstract.PortedObject]\n        description: a description of the contents of a port \n\n    Raises:\n        ValueError: if an invalid name is given. By default, this is any string containing a period `\".\"`.\n    \"\"\"\n    if HIERARCHY_SEPARATOR in name:\n        raise ValueError(\n            f\"Port '{name}': Port names must not contain '{HIERARCHY_SEPARATOR}'.\"\n        )\n    self.name = name\n    self.description = description\n</code></pre>"},{"location":"reference/build/system/","title":"System","text":""},{"location":"reference/build/system/#psymple.build.system.FunctionHandler","title":"<code>FunctionHandler</code>","text":"<p>Base class handing the creation and storage of system-wide utility functions and parameters.</p>"},{"location":"reference/build/system/#psymple.build.system.FunctionHandler.add_system_parameter","title":"<code>add_system_parameter(name, function, signature=None)</code>","text":"<p>A system parameter is a system-wide function which, if not constant, may only depend on the independent  system variable <code>time</code> or existing system parameters.</p> PARAMETER DESCRIPTION <code>name</code> <p>the string identifier of the system parameter.</p> <p> TYPE: <code>str</code> </p> <code>function</code> <p>a callable function or a string representation of its output.</p> <p> TYPE: <code>Callable | str | int | float</code> </p> <code>signature</code> <p>the function signature. See <code>Notes</code> below for more details.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>if the input <code>function</code> is not of a parsable type.</p> Notes <p>If function is callable, the signature should be provided if the function arguments names are not system parameters or time. The following are acceptable calls:</p> <pre><code>&gt;&gt;&gt; system.add_system_parameter(\"T_avg\", lambda T_min, T_max: (T_min + T_max)/2)\n&gt;&gt;&gt; system.add_system_parameter(\"T_avg\", lambda a, b: (a+b)/2, signature=(\"T_min\", \"T_max\"))\n</code></pre> <p>While the following call will fail because <code>\"a\"</code> and <code>\"b\"</code> are not recognised as system parameters. <pre><code>&gt;&gt;&gt; system.add_system_paramter(\"T_avg\", lambda a, b: (a+b)/2)\n</code></pre></p> <p>If the function is symbolic, a signature only needs to be provided to control the display order of the function arguments. If not provided, the generation of the signature does not preserve the order in which the symbols appear. This does not affect the computation of the system parameter. For example,</p> <pre><code>&gt;&gt;&gt; system.add_system_parameter(\"T_ratio\", \"T_max / T_min\")\n</code></pre> <p>will always compute <code>T_ratio = T_max / T_min</code>, but may display as <code>T_ratio (T_max, T_min)</code> or <code>T_ratio (T_min, T_max)</code>.</p> <p>The provided signature must be a list or tuple containing exactly the symbols in the expression in the required order, for example:</p> <pre><code>&gt;&gt;&gt; system.add_system_parameter(\"T_ratio\", \"T_max / T_min\", (\"T_max\", \"T_min\"))\n</code></pre> <p>Then whenever <code>T_ratio</code> is written in an assignment definition, it will be interpreted and displayed as the function <code>T_ratio(T_max, T_min)</code>.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def add_system_parameter(\n    self, name: str, function: Callable | str | int | float, signature: tuple = None\n):\n    \"\"\"\n    A system parameter is a system-wide function which, if not constant, may only depend on the independent \n    system variable `time` or existing system parameters.\n\n    Args:\n        name: the string identifier of the system parameter.\n        function: a callable function or a string representation of its output.\n        signature: the function signature. See `Notes` below for more details.\n\n    Raises:\n        TypeError: if the input `function` is not of a parsable type.\n\n    Notes:\n        If function is callable, the signature should be provided if the function arguments names are not system\n        parameters or time. The following are acceptable calls:\n\n        ```\n        &gt;&gt;&gt; system.add_system_parameter(\"T_avg\", lambda T_min, T_max: (T_min + T_max)/2)\n        &gt;&gt;&gt; system.add_system_parameter(\"T_avg\", lambda a, b: (a+b)/2, signature=(\"T_min\", \"T_max\"))\n        ```\n\n        While the following call will fail because `\"a\"` and `\"b\"` are not recognised as system parameters.\n        ```\n        &gt;&gt;&gt; system.add_system_paramter(\"T_avg\", lambda a, b: (a+b)/2)\n        ```\n\n        If the function is symbolic, a signature only needs to be provided to control the display order of the\n        function arguments. If not provided, the generation of the signature does not preserve the order in\n        which the symbols appear. This does not affect the computation of the system parameter. For example,\n\n        ```\n        &gt;&gt;&gt; system.add_system_parameter(\"T_ratio\", \"T_max / T_min\")\n        ```\n\n        will always compute `T_ratio = T_max / T_min`, but may display as `T_ratio (T_max, T_min)` or\n        `T_ratio (T_min, T_max)`.\n\n        The provided signature must be a list or tuple containing exactly the symbols in the expression in the\n        required order, for example:\n\n        ```\n        &gt;&gt;&gt; system.add_system_parameter(\"T_ratio\", \"T_max / T_min\", (\"T_max\", \"T_min\"))\n        ```\n\n        Then whenever `T_ratio` is written in an assignment definition, it will be interpreted and displayed\n        as the function `T_ratio(T_max, T_min)`.\n    \"\"\"\n    if name in self.system_parameters:\n        warnings.warn(\n            f\"The system parameter {name} has already been defined. It will be overwritten.\"\n        )\n    if callable(function):\n        args, nargs = self._inspect_signature(function)\n        if signature:\n            if signature != args:\n                if len(signature) not in nargs:\n                    raise ValueError(\n                        f\"Signature validation failed. The provided signature {signature}\"\n                        f\"is not a length accepted by the provided function: {nargs}.\"\n                    )\n        else:\n            signature = args\n        self._check_are_system_parameters(*signature)\n        sym_func = self._add_callable_function(name, function, nargs=nargs)\n    elif isinstance(function, (str, int, float)):\n        function = str(function)\n        sym_signature = self._generate_signature(function)\n        if signature:\n            assert all([isinstance(s, str) for s in signature])\n            assert set(signature) == set(sym_signature)\n        else:\n            try:\n                value = float(function)\n            except:\n                warnings.warn(\n                    f\"A signature for function {name} was not provided. The appearance of \"\n                    f\"the function in displayed expressions may not be as expected.\"\n                )\n            signature = sym_signature\n        self._check_are_system_parameters(*signature)\n        sym_func = self._add_symbolic_function(name, function, signature)\n    else:\n        raise TypeError(f\"Function {function} of type {type(function)} cannot be parsed.\")\n    # The signature needs to take into account sub-dependencies of existing system parameters\n    sig = tuple(parse_expr(s, local_dict=self.system_parameters) for s in signature)\n    if sig:\n        self.system_parameters.update({name: sym_func(*sig)})\n    else:\n        self.system_parameters.update({name: sym_func()})\n</code></pre>"},{"location":"reference/build/system/#psymple.build.system.FunctionHandler.add_utility_function","title":"<code>add_utility_function(name, function, signature=None)</code>","text":"<p>A utility function is a system-wide function which can depend on any further created variable or parameter. They expand functions available to the user when defining assignments.</p> PARAMETER DESCRIPTION <code>name</code> <p>the string identifier of the system parameter.</p> <p> TYPE: <code>str</code> </p> <code>function</code> <p>a callable function or a string representation of its output.</p> <p> TYPE: <code>Callable | str</code> </p> <code>signature</code> <p>the function signature. See <code>Notes</code> below for more details.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>if the input <code>function</code> is not of a parsable type.</p> Notes <p>If function is callable, its signature will be inspected to determine the range of acceptable number of inputs. This is used to validate function entry in the creation of assignments.</p> <pre><code>&gt;&gt;&gt; from numpy import sin\n&gt;&gt;&gt; system.add_utility_function(\"new_sin\", sin)\n</code></pre> <p>Entering <code>new_sin(a,b)</code> in an assignment will raise an exception because <code>numpy.sin</code> accepts exactly one argument. A signature can be provided to restrict the number of inputs of a function. This is currently not recommended, and no signature argument should be provided.</p> <p>If function is symbolic, a signature should be provided if the order of function arguments matters. If not provided, the function may not behave as expected. The provided signature must be a list or tuple containing exactly the symbols in the expression in the required order. For example,</p> <pre><code>&gt;&gt;&gt; system.add_utility_function(\"exp\", \"a**b\")\n</code></pre> <p>may evaluate as <code>exp(x,y) = x**y</code> or <code>exp(x,y) = y**x</code>. While,</p> <pre><code>&gt;&gt;&gt; system.add_utility_function(\"exp\", \"a**b\", (\"a\", \"b\"))\n</code></pre> <p>will always evaluate as <code>exp(x,y) = x**y</code>.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def add_utility_function(self, name: str, function: Callable | str, signature: tuple = None):\n    \"\"\"\n    A utility function is a system-wide function which can depend on any further created variable or parameter.\n    They expand functions available to the user when defining assignments.\n\n    Args:\n        name: the string identifier of the system parameter.\n        function: a callable function or a string representation of its output.\n        signature: the function signature. See `Notes` below for more details.\n\n    Raises:\n        TypeError: if the input `function` is not of a parsable type.\n\n    Notes:\n        If function is callable, its signature will be inspected to determine the range of acceptable number of\n        inputs. This is used to validate function entry in the creation of assignments.\n\n        ```\n        &gt;&gt;&gt; from numpy import sin\n        &gt;&gt;&gt; system.add_utility_function(\"new_sin\", sin)\n        ```\n\n        Entering `new_sin(a,b)` in an assignment will raise an exception because `numpy.sin` accepts exactly one\n        argument. A signature can be provided to restrict the number of inputs of a function. _This is currently\n        **not** recommended, and no signature argument should be provided_.\n\n        If function is symbolic, a signature should be provided if the order of function arguments matters.\n        If not provided, the function may not behave as expected. The provided signature must be a list or\n        tuple containing exactly the symbols in the expression in the required order. For example,\n\n        ```\n        &gt;&gt;&gt; system.add_utility_function(\"exp\", \"a**b\")\n        ```\n\n        may evaluate as `exp(x,y) = x**y` or `exp(x,y) = y**x`. While,\n\n        ```\n        &gt;&gt;&gt; system.add_utility_function(\"exp\", \"a**b\", (\"a\", \"b\"))\n        ```\n\n        will always evaluate as `exp(x,y) = x**y`.\n    \"\"\"\n    if name in self.utility_functions:\n        warnings.warn(\n            f\"The utility function {name} has already been defined. It will be overwritten.\"\n        )\n    if callable(function):\n        _, nargs = self._inspect_signature(function)\n        if signature:\n            assert set(signature).issubset(set(nargs))\n            nargs = signature\n        sym_func = self._add_callable_function(name, function, nargs=nargs)\n    elif isinstance(function, str):\n        sym_signature = self._generate_signature(function)\n        if signature:\n            assert set(signature) == set(sym_signature)\n        else:\n            warnings.warn(\n                f\"A signature for function {name} was not provided. The behaviour of \"\n                \"the function may not be as expected.\"\n            )\n            signature = sym_signature\n        sym_func = self._add_symbolic_function(name, function, signature)\n    else:\n        raise TypeError(f\"Function {function} of type {type(function)} cannot be parsed.\")\n    self.utility_functions.update({name: sym_func})\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System","title":"<code>System(ported_object=None, utility_functions=[], system_parameters=[], time_symbol='T', compile=False)</code>","text":"<p>               Bases: <code>FunctionHandler</code>, <code>SetterObject</code></p> <p>A <code>System</code> is a three-way interface between:</p> <ol> <li>A <code>PortedObject</code> instance     defining a model;</li> <li> <p>Collections of data providing context to symbols and functions of     <code>Assignment</code> instances attached to     the <code>PortedObject</code> instance. The three main data sources are:</p> <ul> <li>time: the independent system variable which is simulated over;</li> <li>utility functions: which provide a system-wide definition of     a function call, and;</li> <li>system parameters: which provide a system-wide definition of     a symbol;</li> </ul> </li> <li> <p>A <code>Simulation</code> instance which allows     a model defined by the <code>PortedObject</code> instance to be simulated.</p> </li> </ol> PARAMETER DESCRIPTION <code>ported_object</code> <p>instance of <code>PortedObject</code> or `PortedObjectData defining the system model.</p> <p> TYPE: <code>PortedObject | PortedObjectData</code> DEFAULT: <code>None</code> </p> <code>utility_functions</code> <p>list of the utility functions available in the system. See documentation for <code>add_utility_function</code> for acceptable values.</p> <p> TYPE: <code>list[dict | tuple]</code> DEFAULT: <code>[]</code> </p> <code>system_parameters</code> <p>list of the system parameters available in the system. See documentation for <code>add_system_paramter</code> for acceptable values.</p> <p> TYPE: <code>list[dict | tuple]</code> DEFAULT: <code>[]</code> </p> <code>time_symbol</code> <p>The symbol used for the independent variable time in the system.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'T'</code> </p> <code>compile</code> <p>If <code>True</code> and <code>ported_object</code> is provided, then system will be compiled automatically.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Warning <p>Overriding the time_symbol from <code>\"T\"</code> is not currently supported.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def __init__(\n    self,\n    ported_object: PortedObject | PortedObjectData = None,\n    utility_functions: list[dict | tuple] = [],\n    system_parameters: list[dict | tuple] = [],\n    time_symbol: str = \"T\",\n    compile: bool = False,\n):\n    \"\"\"\n    Create a System instance.\n\n    Args:\n        ported_object: instance of `PortedObject` or `PortedObjectData defining the system model.\n        utility_functions: list of the utility functions available in the system. See documentation\n            for [`add_utility_function`][psymple.build.System.add_utility_function] for acceptable values.\n        system_parameters: list of the system parameters available in the system. See documentation\n            for [`add_system_paramter`][psymple.build.System.add_system_parameter] for acceptable values.\n        time_symbol: The symbol used for the independent variable time in the system.\n        compile: If `True` and `ported_object` is provided, then system will be compiled automatically.\n\n    warning: Warning\n        Overriding the time_symbol from `\"T\"` is not currently supported.\n    \"\"\"\n    self.lambdify_ns = [\"numpy\", \"scipy\"]\n    self.system_parameters = {}\n    self.utility_functions = {}\n    self.compiled = False\n    self.simulations = {}\n    self.ported_object = None\n\n    if time_symbol != \"T\":\n        warnings.warn(\n            f\"time symbol {time_symbol} has not been tested. Reverting back to T.\"\n        )\n        time_symbol = \"T\"\n    self._create_time_variable(time_symbol)\n\n    self._add_function(\"utility_function\", *utility_functions)\n    self._add_function(\"system_parameter\", *system_parameters)\n\n    if ported_object:\n        self.set_object(ported_object, compile=compile)\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.compile","title":"<code>compile(child=None)</code>","text":"<p>Compile the system at the specified ported object. This will compile the specified ported object, and then create the necessary variables and parameters for simulation.</p> PARAMETER DESCRIPTION <code>child</code> <p>a string identifying a child ported object from <code>self.ported_object</code>. If not provided, <code>self.ported_object</code> will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Source code in <code>psymple/build/system.py</code> <pre><code>def compile(self, child: str = None):\n    \"\"\"\n    Compile the system at the specified ported object. This will compile the specified ported object,\n    and then create the necessary variables and parameters for simulation.\n\n    Args:\n        child: a string identifying a child ported object from `self.ported_object`. If not provided,\n            `self.ported_object` will be used.\n    \"\"\"\n    self.simulations = {}\n    self.required_inputs = []\n\n    if not self.ported_object:\n        raise SystemError(\n            \"No ported object specified in system. Use set_object() to set one first.\"\n        )\n\n    ported_object = self._build_ported_object()\n\n    if child:\n        ported_object = ported_object._get_child(child)\n\n    compiled = ported_object.compile()\n\n    variable_assignments, parameter_assignments = compiled.get_assignments()\n    # self.sub_system_parameters(variable_assignments, parameter_assignments)\n\n    required_inputs = compiled.get_required_inputs()\n\n    self._reset_variables_parameters()\n\n    variables, parameters = self._get_symbols(\n        variable_assignments, parameter_assignments, required_inputs\n    )\n\n    self._create_simulation_variables(\n        variable_assignments, variables | {self.time.symbol}, parameters\n    )\n    self._create_simulation_parameters(\n        parameter_assignments, variables | {self.time.symbol}, parameters\n    )\n    self._create_input_parameters(required_inputs)\n    self.compiled = True\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.compute_parameter_update_order","title":"<code>compute_parameter_update_order()</code>","text":"<p>Computes the dependency tree of parameters in <code>self.parameters</code>.</p> <p>By performing a topological sort, the correct substitution order of parameters is determined. For example if <code>par_a = f(par_b)</code> and <code>par_b = g(par_c)</code>, the  substitution <code>par_b -&gt; g(par_c)</code> must be performed before <code>par_a -&gt; f(par_b)</code>.</p> <p>If a topologial sort fails, there are cyclic dependencies in the parameter tree and an exception is raised. </p> RETURNS DESCRIPTION <code>nodes</code> <p>the keys of <code>self.parameters</code> in sorted order.</p> <p> TYPE: <code>list[Symbol]</code> </p> RAISES DESCRIPTION <code>SystemError</code> <p>if there are cyclic dependencies.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def compute_parameter_update_order(self) -&gt; list[Symbol]:\n    \"\"\"\n    Computes the dependency tree of parameters in `self.parameters`.\n\n    By performing a topological sort, the correct substitution order of parameters\n    is determined. For example if `par_a = f(par_b)` and `par_b = g(par_c)`, the \n    substitution `par_b -&gt; g(par_c)` must be performed before `par_a -&gt; f(par_b)`.\n\n    If a topologial sort fails, there are cyclic dependencies in the parameter tree\n    and an exception is raised. \n\n    Returns:\n        nodes: the keys of `self.parameters` in sorted order.\n\n    Raises:\n        SystemError: if there are cyclic dependencies. \n    \"\"\"\n    variable_symbols = set(self.variables.keys())\n    parameter_symbols = self.parameters\n    G = nx.DiGraph()\n    G.add_nodes_from(parameter_symbols)\n    for parameter in self.parameters.values():\n        parsym = parameter.symbol\n        if parsym != parameter.expression:\n            # Skip identity parameters\n            for dependency in parameter.dependent_parameters:\n                if dependency in parameter_symbols:\n                    G.add_edge(dependency, parsym)\n                elif dependency not in (variable_symbols | {self.time.symbol}):\n                    raise SystemError(\n                        f\"Parameter {parsym} references undefined symbol {dependency}\"\n                    )\n    try:\n        nodes = list(nx.topological_sort(G))\n    except nx.exception.NetworkXUnfeasible:\n        raise SystemError(f\"System parameters contain cyclic dependencies\")\n    return nodes\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.create_simulation","title":"<code>create_simulation(name=None, solver='continuous', initial_values={}, input_parameters={})</code>","text":"<p>Create a Simulation instance from the system. </p> PARAMETER DESCRIPTION <code>name</code> <p>if provided, the simulation will be stored in <code>self.simulations[name]</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>solver</code> <p>solver method to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'continuous'</code> </p> <code>initial_values</code> <p>a dictionary of <code>variable: value</code> pairs where <code>variable</code> is the string identifier of a variable in <code>self.variables</code> and <code>value</code> is <code>int</code> or <code>float</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>input_parameters</code> <p>a dictionary of <code>parameter: value</code> pairs, where <code>parameter</code> is the string identifier of a parameter (an entry from <code>self.parameters</code>) and <code>value</code> is the value or function to assign.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>simulation</code> <p>the <code>Simulation</code> class specified by the arguments provided.</p> <p> TYPE: <code>Simulation</code> </p> RAISES DESCRIPTION <code>SystemError</code> <p>if the system has not been compiled.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def create_simulation(\n    self,\n    name: str = None,\n    solver: str = \"continuous\",\n    initial_values: dict = {},\n    input_parameters: dict = {},\n) -&gt; Simulation:\n    \"\"\"\n    Create a Simulation instance from the system. \n\n    Args:\n        name: if provided, the simulation will be stored in `self.simulations[name]`.\n        solver: solver method to use.\n        initial_values: a dictionary of `variable: value` pairs where `variable` is the string\n            identifier of a variable in `self.variables` and `value` is `int` or `float`.\n        input_parameters: a dictionary of `parameter: value` pairs, where `parameter` is the string\n            identifier of a parameter (an entry from `self.parameters`) and `value` is the value\n            or function to assign.\n\n    Returns:\n        simulation: the `Simulation` class specified by the arguments provided.\n\n    Raises:\n        SystemError: if the system has not been compiled.\n    \"\"\"\n    if not self.compiled:\n        raise SystemError(f\"System has not been compiled.\")\n    if params := self._get_required_parameters() - input_parameters.keys():\n        warnings.warn(\n            f\"The parameters {params} have no default value. This must be provided before a simulation run.\"\n        )\n    simulation = Simulation(self, solver, initial_values, input_parameters)\n    if name:\n        self.simulations.update({name: simulation})\n    return simulation\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.get_readable_symbols","title":"<code>get_readable_symbols(keep_surface_symbols=True, hash_symbols=False)</code>","text":"<p>Generates short symbols for the variables and parameters in the system.</p> PARAMETER DESCRIPTION <code>keep_surface_symbols</code> <p>if True, any symbol exposed at the surface ported object is preserved.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hash_symbols</code> <p>if True, any non-preserved symbol is replaced with a hashable version by replacing <code>HIERARCHY_SEPARATOR</code> with <code>\"_\"</code>, e.g. <code>x.y.z -&gt; x_y_z</code>. Otherwise:</p> <pre><code>- Variables are mapped to `x_i`, where `i` is incremented for each variable.\n- Parameters are mapped to `a_i`, where `i` is incremented for each parameter.\n</code></pre> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Warning <p>This is currently a very crude implementation. In the future, a lot more customisation will be offered.</p> RETURNS DESCRIPTION <code>vars_dict</code> <p>a mapping of variable symbols to readable variable symbols</p> <p> TYPE: <code>dict</code> </p> <code>pars_dict</code> <p>a mapping of parameter symbols to readable parameter symbols</p> <p> TYPE: <code>dict</code> </p> Source code in <code>psymple/build/system.py</code> <pre><code>def get_readable_symbols(self, keep_surface_symbols: bool = True, hash_symbols: bool = False) -&gt; tuple[dict, dict]:\n    \"\"\"\n    Generates short symbols for the variables and parameters in the system.\n\n    Args:\n        keep_surface_symbols: if True, any symbol exposed at the surface ported object is preserved.\n        hash_symbols: if True, any non-preserved symbol is replaced with a hashable version by\n            replacing `HIERARCHY_SEPARATOR` with `\"_\"`, e.g. `x.y.z -&gt; x_y_z`. Otherwise:\n\n                - Variables are mapped to `x_i`, where `i` is incremented for each variable.\n                - Parameters are mapped to `a_i`, where `i` is incremented for each parameter.\n\n    warning: Warning\n        This is currently a very crude implementation. In the future, a lot more\n        customisation will be offered.\n\n    Returns:\n        vars_dict: a mapping of variable symbols to readable variable symbols\n        pars_dict: a mapping of parameter symbols to readable parameter symbols\n    \"\"\"\n    vars_symbols = self.variables.keys()\n    pars_symbols = self.parameters.keys()\n    if keep_surface_symbols:\n        surface_vars_symbols = {v for v in vars_symbols if HIERARCHY_SEPARATOR not in v.name}\n        edit_vars_symbols = vars_symbols - surface_vars_symbols\n        surface_pars_symbols = {p for p in pars_symbols if HIERARCHY_SEPARATOR not in p.name}\n        edit_pars_symbols = pars_symbols - surface_pars_symbols\n    else:\n        edit_vars_symbols = vars_symbols\n        edit_pars_symbols = pars_symbols\n    if hash_symbols:\n        vars_dict = {v: Symbol(v.name.replace(HIERARCHY_SEPARATOR, \"_\")) for v in edit_vars_symbols}\n        pars_dict = {p: Symbol(p.name.replace(HIERARCHY_SEPARATOR, \"_\")) for p in edit_pars_symbols}\n    else:\n        vars_dict = {v: Symbol(f\"x_{i}\") for i, v in enumerate(edit_vars_symbols)}\n        pars_dict = {p: Symbol(f\"a_{i}\") for i, p in enumerate(edit_pars_symbols)}\n    vars_dict.update({self.time.symbol: Symbol(\"t\")}) \n    if keep_surface_symbols: \n        vars_dict |= {v: v for v in surface_vars_symbols}\n        pars_dict |= {p: p for p in surface_pars_symbols}\n    return vars_dict, pars_dict\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.get_readout","title":"<code>get_readout(vars_dict=None, pars_dict=None)</code>","text":"<p>Get a LaTeX-readable summary of the system ODEs and functions.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def get_readout(self, vars_dict: dict = None, pars_dict: dict = None) -&gt; str:\n    \"\"\"\n    Get a LaTeX-readable summary of the system ODEs and functions.\n    \"\"\"\n    if not vars_dict:\n        vars_dict, _ = self.get_readable_symbols()\n    if not pars_dict:\n        _, pars_dict = self.get_readable_symbols()\n    odes = [\n        var.get_readout(self.time.symbol, vars_dict, pars_dict)\n        for var in self.variables.values()\n    ]\n    functions = [\n        par.get_readout(vars_dict, pars_dict) for par in self.parameters.values()\n    ]\n    print(f\"system ODEs: \\[{self._combine_latex(*odes)}\\]\")\n    print(f\"system functions: \\[{self._combine_latex(*functions)}\\]\")\n    print(f\"variable mappings: {vars_dict}\")\n    print(f\"parameter mappings: {pars_dict}\")\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.set_initial_values","title":"<code>set_initial_values(values)</code>","text":"<p>Set initial values at the system level. System must first have an associated ported object and must be compiled.</p> <p>Initial values must be <code>int</code> or <code>float</code> instances only.</p> PARAMETER DESCRIPTION <code>values</code> <p>a dictionary of <code>variable: value</code> pairs where <code>variable</code> is the string identifier of a variable in <code>self.variables</code> and <code>value</code> is <code>int</code> or <code>float</code>.</p> <p> TYPE: <code>dict[str, int | float]</code> </p> Source code in <code>psymple/build/system.py</code> <pre><code>def set_initial_values(self, values: dict[str, int | float]):\n    \"\"\"\n    Set initial values at the system level. System must first have an associated ported object and\n    must be compiled.\n\n    Initial values must be `int` or `float` instances only.\n\n    Args:\n        values: a dictionary of `variable: value` pairs where `variable` is the string\n            identifier of a variable in `self.variables` and `value` is `int` or `float`.\n    \"\"\"\n    if not self.compiled:\n        raise SystemError(f\"System has not been compiled.\")\n    super().set_initial_values(values)\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.set_object","title":"<code>set_object(ported_object, compile=True)</code>","text":"<p>Set the ported object in the system. This will override any ported object currently set in the system.</p> PARAMETER DESCRIPTION <code>ported_object</code> <p>instance of <code>PortedObject</code> or <code>PortedObjectData</code> defining the system model.</p> <p> TYPE: <code>PortedObject | PortedObjectData</code> </p> <code>compile</code> <p>if <code>True</code>, <code>compile</code> will be called automatically.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>psymple/build/system.py</code> <pre><code>def set_object(\n    self, ported_object: PortedObject | PortedObjectData, compile: bool = True\n):\n    \"\"\"\n    Set the ported object in the system. This will override any ported object currently\n    set in the system.\n\n    Args:\n        ported_object: instance of `PortedObject` or `PortedObjectData` defining the system model.\n        compile: if `True`, [`compile`][psymple.build.System.compile] will be called automatically.\n    \"\"\"\n    self.ported_object = self._process_ported_object(ported_object)\n    self.compiled = False\n    # Variables and parameters need to be reset for a new object\n    self._reset_variables_parameters()\n    if compile:\n        self.compile()\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.set_parameters","title":"<code>set_parameters(parameter_values={})</code>","text":"<p>Set input parameters at the system level. System must first have an associated ported object and must be compiled.</p> <p>Parameters which can be set or overridden:</p> <ul> <li>any parameter from an input port of the system object, whether it has a default value or not,</li> <li>any parameter from an input port of a nested child of the system object (these must already     have been given a default value, but this can be overridden here).</li> </ul> <p>Parameter values must be constant, or functions of system variable <code>time</code> and/or existing system  parameters.</p> PARAMETER DESCRIPTION <code>parameter_values</code> <p>a dictionary of <code>parameter: value</code> pairs, where <code>parameter</code> is the string identifier of a parameter (an entry from <code>self.parameters</code>) and <code>value</code> is the value or function to assign.</p> <p> TYPE: <code>dict[str, str | int | float]</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>if a value which is not of type <code>str</code>, <code>int</code>, <code>float</code> is entered.</p> <code>ParsingError</code> <p>if the value expression contains forbidden symbols.</p> <code>TypeError</code> <p>if the parameter is fixed and cannot be updated.</p> Source code in <code>psymple/build/system.py</code> <pre><code>def set_parameters(self, parameter_values: dict[str, str | int | float] = {}):\n    \"\"\"\n    Set input parameters at the system level. System must first have an associated ported object and\n    must be compiled.\n\n    Parameters which can be set or overridden:\n\n    - any parameter from an input port of the system object, whether it has a default value or not,\n    - any parameter from an input port of a nested child of the system object (these must already\n        have been given a default value, but this can be overridden here).\n\n    Parameter values must be constant, or functions of system variable `time` and/or existing system \n    parameters.\n\n    Args:\n        parameter_values: a dictionary of `parameter: value` pairs, where `parameter` is the string\n            identifier of a parameter (an entry from `self.parameters`) and `value` is the value\n            or function to assign.\n\n    Raises:\n        TypeError: if a value which is not of type `str`, `int`, `float` is entered.\n        ParsingError: if the value expression contains forbidden symbols.\n        TypeError: if the parameter is fixed and cannot be updated.\n    \"\"\"\n    if not self.compiled:\n        raise SystemError(f\"System has not been compiled.\")\n    super().set_parameters(parameter_values)\n</code></pre>"},{"location":"reference/build/system/#psymple.build.System.to_data","title":"<code>to_data()</code>","text":"<p>Map the system to a <code>SystemData</code> instance. Not currently used for anything.</p> RETURNS DESCRIPTION <code>data</code> <p>a <code>SystemData</code> instance.</p> <p> TYPE: <code>SystemData</code> </p> Source code in <code>psymple/build/system.py</code> <pre><code>def to_data(self) -&gt; SystemData:\n    \"\"\"\n    Map the system to a `SystemData` instance. Not currently used for anything.\n\n    Returns:\n        data: a `SystemData` instance.\n    \"\"\"\n    metadata = {\"compiled\": self.compiled}\n    ported_object = self.ported_object_data\n    return SystemData(metadata=metadata, ported_object=ported_object)\n</code></pre>"},{"location":"reference/build/wires/","title":"Wires","text":""},{"location":"reference/build/wires/#psymple.build.wires.SymbolIdentification","title":"<code>SymbolIdentification(new_symbol, old_symbol)</code>","text":"<p>Class formally identifying two symbols as equal.</p> Warning <p>This class should not be instantiated directly. It is automatically created and accessed when required.</p> PARAMETER DESCRIPTION <code>new_symbol</code> <p>the new symbol</p> <p> TYPE: <code>Symbol</code> </p> <code>old_symbol</code> <p>the symbol to replace</p> <p> TYPE: <code>Symbol</code> </p> Source code in <code>psymple/build/wires.py</code> <pre><code>def __init__(self, new_symbol: Symbol, old_symbol: Symbol):\n    \"\"\"\n    Create a symbol identification.\n\n    Args:\n        new_symbol: the new symbol\n        old_symbol: the symbol to replace\n    \"\"\"\n    self.old_symbol = old_symbol\n    self.new_symbol = new_symbol\n</code></pre>"},{"location":"reference/build/wires/#psymple.build.wires.VariableAggregationWiring","title":"<code>VariableAggregationWiring(child_ports, parent_port, output_name)</code>","text":"<p>Stores the connection of child variable ports in a composite ported object to a specified parent port or internal variable.</p> Warning <p>This class should not be instantiated on its own. Instead, use <code>psymple.build.CompositePortedObject.add_variable_wire</code> or  <code>psymple.build.CompositePortedObject.add_wires</code>.</p> PARAMETER DESCRIPTION <code>child_ports</code> <p>list of ports whose variables will be aggregated.</p> <p> TYPE: <code>list[str]</code> </p> <code>parent_port</code> <p>variable port to expose the aggregation.</p> <p> TYPE: <code>str</code> </p> <code>output_name</code> <p>name to assign internally to the aggregation if it is not exposed.</p> <p> TYPE: <code>str</code> </p> Source code in <code>psymple/build/wires.py</code> <pre><code>def __init__(self, child_ports: list[str], parent_port: str, output_name: str):\n    \"\"\"\n    Create a variable wire.\n\n    Args:\n        child_ports: list of ports whose variables will be aggregated.\n        parent_port: variable port to expose the aggregation.\n        output_name: name to assign internally to the aggregation if it is\n            not exposed.\n    \"\"\"\n    self.child_ports = child_ports\n    self.parent_port = parent_port\n    self.output_name = output_name\n</code></pre>"},{"location":"reference/build/wires/#psymple.build.wires.DirectedWire","title":"<code>DirectedWire(source_port, destination_ports)</code>","text":"<p>Stores the connection of an input port or child output port in a composite ported object to a child input ports and/or an output port.</p> Warning <p>This class should not be instantiated on its own. Instead, use <code>psymple.build.CompositePortedObject.add_directed_wire</code> or  <code>psymple.build.CompositePortedObject.add_wires</code>.</p> PARAMETER DESCRIPTION <code>source_port</code> <p>initial port which the wire reads from.</p> <p> TYPE: <code>str</code> </p> <code>destination_ports</code> <p>list of ports to which the read value is provided.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>psymple/build/wires.py</code> <pre><code>def __init__(self, source_port: str, destination_ports: list[str]):\n    \"\"\"\n    Create a directed wire.\n\n    Args:\n        source_port: initial port which the wire reads from.\n        destination_ports: list of ports to which the read value is provided.\n    \"\"\"\n    self.source_port = source_port\n    self.destination_ports = destination_ports\n</code></pre>"},{"location":"reference/simulate/simulation/","title":"Simulation","text":""},{"location":"reference/simulate/simulation/#psymple.simulate.simulation.SetterObject","title":"<code>SetterObject</code>","text":"<p>Base class handling the updating of attributes of parameters and variables.</p>"},{"location":"reference/simulate/simulation/#psymple.simulate.simulation.SetterObject.set_initial_values","title":"<code>set_initial_values(initial_values)</code>","text":"<p>Set initial values.</p> <p>Initial values must be <code>int</code> or <code>float</code> instances only.</p> PARAMETER DESCRIPTION <code>initial_values</code> <p>a dictionary of <code>variable: value</code> pairs where <code>variable</code> is the string identifier of a variable in <code>self.variables</code> and <code>value</code> is <code>int</code> or <code>float</code>.</p> <p> TYPE: <code>dict[str, int | float]</code> </p> Source code in <code>psymple/simulate/simulation.py</code> <pre><code>def set_initial_values(self, initial_values: dict[str, int | float]):\n    \"\"\"\n    Set initial values.\n\n    Initial values must be `int` or `float` instances only.\n\n    Args:\n        initial_values: a dictionary of `variable: value` pairs where `variable` is the string\n            identifier of a variable in `self.variables` and `value` is `int` or `float`.\n    \"\"\"\n    for var, value in initial_values.items():\n        self.variables[var].initial_value = value\n</code></pre>"},{"location":"reference/simulate/simulation/#psymple.simulate.simulation.SetterObject.set_parameters","title":"<code>set_parameters(parameter_values={})</code>","text":"<p>Set input parameters.</p> <p>Parameter values must be constant, or functions of system variable <code>time</code> and/or existing system  parameters.</p> PARAMETER DESCRIPTION <code>parameter_values</code> <p>a dictionary of <code>parameter: value</code> pairs, where <code>parameter</code> is the string identifier of a parameter (an entry from <code>self.parameters</code>) and <code>value</code> is the value or function to assign.</p> <p> TYPE: <code>dict[str, str | int | float]</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>if a value which is not of type <code>str</code>, <code>int</code>, <code>float</code> is entered.</p> <code>ParsingError</code> <p>if the value expression contains forbidden symbols.</p> <code>TypeError</code> <p>if the parameter is fixed and cannot be updated.</p> Source code in <code>psymple/simulate/simulation.py</code> <pre><code>def set_parameters(self, parameter_values: dict[str, str | int | float] = {}):\n    \"\"\"\n    Set input parameters.\n\n    Parameter values must be constant, or functions of system variable `time` and/or existing system \n    parameters.\n\n    Args:\n        parameter_values: a dictionary of `parameter: value` pairs, where `parameter` is the string\n            identifier of a parameter (an entry from `self.parameters`) and `value` is the value\n            or function to assign.\n\n    Raises:\n        TypeError: if a value which is not of type `str`, `int`, `float` is entered.\n        ParsingError: if the value expression contains forbidden symbols.\n        TypeError: if the parameter is fixed and cannot be updated.\n    \"\"\"\n    for parameter, value in parameter_values.items():\n        parameter = self.parameters[parameter]\n        if isinstance(value, str):\n            value = parse_expr(\n                value, local_dict=self.system_parameters | self.utility_functions\n            )\n        elif isinstance(value, (int, float)):\n            value = Number(value)\n        else:\n            raise TypeError(f\"Parameter {parameter.name} was provided value {value} \"\n                            f\"of type {type(value)} which is not of type [str, float, int].\")\n        if bad_symbols := (\n            value.free_symbols\n            - {self.time.symbol}\n            - set(self.system_parameters.values())\n        ):\n            raise ParsingError(f\"The symbols {bad_symbols} cannot be used.\")\n        if parameter.type in {\"default_optional\", \"default_exposable\", \"required\"}:\n            parameter.change_parameter_value(value, {self.time.symbol}, value.free_symbols - {self.time.symbol})\n            parameter.type = \"default_optional\"\n        else:\n            raise TypeError(\n                f\"The value of parameter {parameter.name} is fixed and cannot be updated.\"\n            )\n</code></pre>"},{"location":"reference/simulate/simulation/#psymple.simulate.Simulation","title":"<code>Simulation(system, solver='continuous', initial_values={}, input_parameters={})</code>","text":"<p>               Bases: <code>SetterObject</code></p> <p>A Simulation is a basic object which produces a simulable system which is passed to a solver.</p> Information: <p>The simulation capability of <code>psymple</code> is fairly rudimentary. These features are currently designed to exemplify the functionality of the rest of the package.</p> PARAMETER DESCRIPTION <code>system</code> <p>the system to simulate</p> <p> TYPE: <code>System</code> </p> <code>solver</code> <p>solver type</p> <p> TYPE: <code>str</code> DEFAULT: <code>'continuous'</code> </p> <code>initial_values</code> <p>initial values</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>input_parameters</code> <p>input_parameters</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/simulate/simulation.py</code> <pre><code>def __init__(\n    self,\n    system: System,\n    solver: str = \"continuous\",\n    initial_values: dict = {},\n    input_parameters: dict = {},\n):\n    \"\"\"\n    Create a Simulation instance.\n\n    Args:\n        system: the system to simulate\n        solver: solver type\n        initial_values: initial values\n        input_parameters: input_parameters\n    \"\"\"\n    self.variables = deepcopy(system.variables)\n    self.parameters = self._create_ordered_parameters(\n        system.parameters, system.compute_parameter_update_order()\n    )\n    self.time = deepcopy(system.time)\n\n    self.solver = solver\n\n    self.system_parameters = deepcopy(system.system_parameters)\n    self.utility_functions = deepcopy(system.utility_functions)\n    self.set_initial_values(initial_values)\n    self.set_parameters(input_parameters)\n\n    self.lambdify_ns = deepcopy(system.lambdify_ns)\n    self.solver_symbols = system.get_readable_symbols()\n</code></pre>"},{"location":"reference/simulate/simulation/#psymple.simulate.Simulation.plot_solution","title":"<code>plot_solution(variables=None, t_range=None)</code>","text":"<p>Produce a simple solution plot of time against a selection of variables.</p> PARAMETER DESCRIPTION <code>variables</code> <p>a <code>list</code> of keys identifying variables in <code>self.variables</code>, or a <code>dict</code> of <code>key: option</code> pairs, where <code>key</code> identifies a variable in <code>self.variables</code> and <code>option</code> is a <code>str</code> or <code>dict</code> which is passed to <code>matplotlib.pyplot.plot</code>. If <code>None</code>, all variables are plotted on the same axes.</p> <p> TYPE: <code>list | dict</code> DEFAULT: <code>None</code> </p> <code>t_range</code> <p>a list of the form <code>[t_start, t_end]</code> defining the range displayed on the time axis. If <code>None</code>, the time axis is determined by <code>self.variables.time.time_series</code>.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> Source code in <code>psymple/simulate/simulation.py</code> <pre><code>def plot_solution(self, variables: list | dict = None, t_range: list = None):\n    \"\"\"\n    Produce a simple solution plot of time against a selection of variables.\n\n    Args:\n        variables: a `list` of keys identifying variables in `self.variables`, or a `dict` of\n            `key: option` pairs, where `key` identifies a variable in `self.variables` and\n            `option` is a `str` or `dict` which is passed to `matplotlib.pyplot.plot`. If `None`,\n            all variables are plotted on the same axes.\n        t_range: a list of the form `[t_start, t_end]` defining the range displayed on the time\n            axis. If `None`, the time axis is determined by `self.variables.time.time_series`.\n    \"\"\"\n    t_series = self.time.time_series\n    if t_range is None:\n        sl = slice(None, None)\n    else:\n        lower = bisect(t_series, t_range[0])\n        upper = bisect(t_series, t_range[1])\n        sl = slice(lower, upper)\n    if not variables:\n        variables = {v: {} for v in self.variables}\n    if isinstance(variables, set):\n        variables = {v: {} for v in variables}\n    legend = []\n    for var_name, options in variables.items():\n        variable = self.variables[var_name]\n        if isinstance(options, str):\n            plt.plot(t_series[sl], variable.time_series[sl], options)\n        else:\n            plt.plot(t_series[sl], variable.time_series[sl], **options)\n        legend.append(variable.symbol.name)\n    plt.legend(legend, loc=\"best\")\n    plt.xlabel(\"time\")\n    plt.grid()\n    plt.show()\n</code></pre>"},{"location":"reference/simulate/simulation/#psymple.simulate.Simulation.simulate","title":"<code>simulate(t_end, print_solve_time=False, **options)</code>","text":"<p>Simulate a system by calling the instance of <code>Solver</code> specified by <code>self.solver</code>. Currently,  this is either a discrete (Euler forward) integrator, or a a continuosu integrator implemented as a call to <code>scipy.integrate.solve_ivp</code>.</p> PARAMETER DESCRIPTION <code>t_end</code> <p>when to terminate the simulation. Currently this must be a positive integer.</p> <p> TYPE: <code>int</code> </p> <code>print_solve_time</code> <p>if <code>True</code>, the time taken by the solver will be printed in the terminal.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**options</code> <p>options to pass to the <code>Solver</code> instance.</p> <p> DEFAULT: <code>{}</code> </p> Source code in <code>psymple/simulate/simulation.py</code> <pre><code>def simulate(self, t_end: int, print_solve_time: bool = False, **options):\n    \"\"\"\n    Simulate a system by calling the instance of `Solver` specified by `self.solver`. Currently, \n    this is either a discrete (Euler forward) integrator, or a a continuosu integrator implemented\n    as a call to `scipy.integrate.solve_ivp`.\n\n    Args:\n        t_end: when to terminate the simulation. Currently this must be a positive integer.\n        print_solve_time: if `True`, the time taken by the solver will be printed in the terminal.\n        **options: options to pass to the `Solver` instance.\n    \"\"\"\n    self._compute_substitutions()\n    if self.solver in SOLVER_ALIASES[\"discrete\"]:\n        assert \"n_steps\" in options.keys()\n        n_steps = options[\"n_steps\"]\n        solver = DiscreteIntegrator(self, t_end, n_steps)\n    elif self.solver in SOLVER_ALIASES[\"continuous\"]:\n        solver = ContinuousIntegrator(self, t_end)\n    elif self.solver in SOLVER_ALIASES[\"proceedural\"]:\n        raise NotImplementedError(\"proceedural solving is not implemented\")\n    else:\n        raise NameError(\n            f\"The solver {self.name} is not recognised. Please use one \"\n            f\"from {SOLVER_ALIASES.keys()}\"\n        )\n    t_start = time()\n    solver.run()\n    t_end = time()\n    if print_solve_time:\n        print(\n            f\"Solution time with method '{self.solver}': {t_end - t_start} seconds.\"\n        )\n</code></pre>"},{"location":"reference/simulate/solvers/","title":"Solvers","text":""},{"location":"reference/simulate/solvers/#psymple.simulate.solvers.solver.Solver","title":"<code>Solver(simulation, t_end)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for system integrators. All subclasses must implement a <code>run</code> method.</p> PARAMETER DESCRIPTION <code>simulation</code> <p>an instance of <code>Simulation</code> to solve.</p> <p> TYPE: <code>Simulation</code> </p> <code>t_end</code> <p>positive integer at which to stop the simulation.</p> <p> TYPE: <code>int</code> </p> Source code in <code>psymple/simulate/solvers/solver.py</code> <pre><code>def __init__(self, simulation: Simulation, t_end: int):\n    \"\"\"\n    Instantiate a solver.\n\n    Args:\n        simulation: an instance of `Simulation` to solve.\n        t_end: positive integer at which to stop the simulation.\n    \"\"\"\n    if t_end &lt;= 0 or not isinstance(t_end, int):\n        raise ValueError(\n            \"Simulation time must terminate at a positive integer, \"\n            f\"not '{t_end}'.\"\n        )\n    self.t_end = t_end\n    self.simulation = simulation\n</code></pre>"},{"location":"reference/simulate/solvers/#psymple.simulate.solvers.ContinuousIntegrator","title":"<code>ContinuousIntegrator(simulation, t_end)</code>","text":"<p>               Bases: <code>Solver</code></p> <p>An interface to <code>scipy.integrate.solve_ivp</code>. The input from the simulation object is manipulated into a form acceptable by the <code>scipy</code> solver and run. </p> Using another solver <p>The attribute <code>_callable</code> created on instantiation is a function with signature <code>(t,y)</code> which  is a form accepted by, or easily coerced into, many other python-implemented ODE solvers.</p> PARAMETER DESCRIPTION <code>simulation</code> <p>an instance of <code>Simulation</code> to solve.</p> <p> TYPE: <code>Simulation</code> </p> <code>t_end</code> <p>positive integer at which to stop the simulation.</p> <p> TYPE: <code>int</code> </p> Source code in <code>psymple/simulate/solvers/scipy_integrator.py</code> <pre><code>def __init__(self, simulation: Simulation, t_end: int):\n    \"\"\"\n    Create a `ContinuousIntegrator` instance.\n\n    Args:\n        simulation: an instance of `Simulation` to solve.\n        t_end: positive integer at which to stop the simulation.\n    \"\"\"\n    super().__init__(simulation, t_end)\n    self.simulation._compute_substitutions()\n    self._callable = self._wrap_for_solve_ivp()\n</code></pre>"},{"location":"reference/simulate/solvers/#psymple.simulate.solvers.ContinuousIntegrator.run","title":"<code>run()</code>","text":"<p>Run the solver according to its parameters.</p> Source code in <code>psymple/simulate/solvers/scipy_integrator.py</code> <pre><code>def run(self):\n    \"\"\"\n    Run the solver according to its parameters.\n    \"\"\"\n    # Initial values are defined as the most recent value in the time series\n    initial_values = [v.time_series[-1] for v in self.simulation.variables.values()]\n    res = solve_ivp(\n        self._callable, [0, self.t_end], initial_values, dense_output=True\n    )\n    # Assign the interpolating solution object to the simulation\n    self.simulation.solution = res.sol\n    # Update time and variable time series with simulation result\n    time_series = arange(0, self.t_end, 0.1)\n    self.simulation.time.time_series = time_series\n    for i, v in enumerate(self.simulation.variables.values()):\n        v.time_series = res.sol(time_series)[i]\n</code></pre>"},{"location":"reference/simulate/solvers/#psymple.simulate.solvers.DiscreteIntegrator","title":"<code>DiscreteIntegrator(simulation, t_end, n_steps)</code>","text":"<p>               Bases: <code>Solver</code></p> <p>A forward Euler method integrator.</p> Warning <p>This is a very rudimentary solver, and performs no accuracy checks or optimisation. It is primarily intended for prototyping or unit testing certain features since its  behaviour is fully controlled.</p> PARAMETER DESCRIPTION <code>simulation</code> <p>an instance of <code>Simulation</code> to solve.</p> <p> TYPE: <code>Simulation</code> </p> <code>t_end</code> <p>positive integer at which to stop the simulation.</p> <p> TYPE: <code>int</code> </p> <code>n_steps</code> <p>the number of substeps to compute per time unit.</p> <p> TYPE: <code>int</code> </p> Source code in <code>psymple/simulate/solvers/discrete_integrator.py</code> <pre><code>def __init__(self, simulation: Simulation, t_end: int, n_steps: int):\n    \"\"\"\n    Create a `DiscreteIntegrator` instance.\n\n    Args:\n        simulation: an instance of `Simulation` to solve.\n        t_end: positive integer at which to stop the simulation.\n        n_steps: the number of substeps to compute per time unit.\n    \"\"\"\n    super().__init__(simulation, t_end)\n    self.n_steps = n_steps\n</code></pre>"},{"location":"reference/simulate/solvers/#psymple.simulate.solvers.DiscreteIntegrator.run","title":"<code>run()</code>","text":"<p>Run the solver according to its parameters.</p> Source code in <code>psymple/simulate/solvers/discrete_integrator.py</code> <pre><code>def run(self):\n    \"\"\"\n    Run the solver according to its parameters.\n    \"\"\"\n    for i in range(self.t_end):\n        self._advance_time_unit(self.n_steps)\n</code></pre>"},{"location":"user_guide/compilation/","title":"Compilation","text":"<p>The definition of a ported object is an object whose ports label and access information inside. </p> <p>When a model is built using ported objects, it produces a formal object, meaning that instead of producing a ported object to the above definition, it produces an object with the data required to build such an object. Compilation is simply the process of forming a ported object with assignments or symbols which are correctly exposed at ports.</p> <p>The advantage of having a compilation process is that it allows a model to be freely edited, and does not impact the order in which components are specified.</p> <p>This is an automatic process</p> <p>The composition process is entirely automated when creating a system. It should only be called on individual ported objects for testing purposes. </p>"},{"location":"user_guide/compilation/#compilation-for-each-ported-object","title":"Compilation for each ported object","text":"<p>For reference, below is a description of what happens inside each type of ported object.</p>"},{"location":"user_guide/compilation/#functional-ported-objects","title":"Functional ported objects","text":"<p>In functional ported objects, the compilation process associates to each assignment with symbol \\(S\\) an output port <code>\"S\"</code> of the ported object which stores the assignment, and to each free symbol \\(F\\) in the expression of any assignment an input port <code>\"F\"</code> of the ported object.</p>"},{"location":"user_guide/compilation/#variable-ported-objects","title":"Variable ported objects","text":"<p>In variable ported objects, the compilation process first checks that the free symbols in the expression of each assignment are either variables or defined at input ports (which can be automatically, or done by the user). Then: </p> <ul> <li>each assignment with symbol \\(S\\) which is to be exposed is stored at a variable port <code>\"S\"</code> of the ported object, </li> <li>each assignment which is not to be exposed is stored as internal information, </li> <li>each free symbol \\(F\\) which is not a variable symbol is associated to an input port <code>\"F\"</code>. </li> </ul>"},{"location":"user_guide/compilation/#composite-ported-objects","title":"Composite ported objects","text":"<p>The compilation process for composite ported objects is slightly more involved. First, each child object is compiled, which results in iterated calls down to the base functional and variable ported objects of a model.</p> <p>The formal information stored in a composite ported object stores non-trivial information about how different functions and differential equations are to be composed. In particular:</p> <ul> <li>Directed wires formally store functional substitutions \\(\\{g_1 \\vert_{x_1 = f}, g_2 \\vert_{x_2 = f}, \\dots, g_k \\vert_{x_k = f} \\}\\) instead of performing them,</li> <li>Variable wires formally store variable aggregations \\((x_1, \\dots, x_k) \\mapsto y\\) instead of performing them.</li> </ul> <p>These are processed as follows.</p> <ol> <li>The assignments at the output ports and variable ports of children are collected. Any assignments stored internally in a child are added to the internal storage of the ported object.</li> <li> <p>Directed wires are processed. The three possible cases are:</p> <ol> <li> <p>If the directed wire goes from a child output port to an outport port of the ported object, the assignment at the source port is forwarded to an assignment at the output port. A formal substitution is made for the source symbol and each other destination symbol of the wire to be replaced by the symbol at the output port.</p> <p>Formal substitution</p> <p>A formal substitution means that the data for the substitution is stored and all substitutions are performed at the end of compilation.</p> </li> <li> <p>If the directed wire goes from a child output port or child variable port to input ports of other child objects, a formal substitution is made for each destination symbol to be replaced by the source symbol.</p> </li> <li>If the directed wire goes from an input port of the ported object to input ports of child objects, a formal substitution is made for each destination symbol to be replaced by the source symbol.  </li> </ol> </li> <li> <p>Variable wires are processed. If the aggregated variable is to be exposed at a variable port, a formal substitution is made for each child variable symbol to be replaced by the destination symbol and the assignment is stored at the variable port. If the variable is not to be exposed, it is stored as internal information with the specified symbol, which is formally substituted for each child variable symbol.</p> </li> <li>Any inputs of children which have not been connected to are converted to a parameter assignment with their default value, which is stored as internal information (a default value must be defined for such ports, otherwise an exception is raised).</li> <li>Formal substitutions are performed as actual symbol substitutions.</li> <li>A renaming process prefixing the symbols of all ports and symbols is performed, allowing them to be uniquely referenced in parent ported objects.</li> </ol> <p>Internal storage</p> <p>The purpose of internal storage is to protect information. While internal information is forwarded to parent ported objects, it is not updated or accessed.</p>"},{"location":"user_guide/simulation/","title":"Running a simulation","text":"<p>Warning</p> <p>The simulation capability of <code>psymple</code> is fairly rudimentary. These features are currently designed to exemplify the functionality of the rest of the package.</p> <p>A Simulation takes a copy of the variables and parameters of a compiled system and numerically simulates them. </p> <p>There are currently two types of simulation in <code>psymple</code>:</p> <ol> <li>A continuous simulator <code>ContinuousIntegrator</code>, which provides an interface to <code>scipy.integrate.solve_ivp</code>, and should be used for any meaningful simulation.</li> <li>A discrete, Euler forward integrator <code>DiscreteIntegrator</code> with fixed time step, which should only be used for basic prototyping and testing.</li> </ol> <p>A simulation can also produce a basic plot of the solution.</p>"},{"location":"user_guide/simulation/#example","title":"Example","text":"<p>The code defining the model and system for the example of an object falling vertically, subject to gravitational and air resistance forces is in the following drop-down box.</p> Falling object example Falling object with air resistance<pre><code>from psymple.build import (\n    FunctionalPortedObject, \n    VariablePortedObject,\n    CompositePortedObject,\n    System,\n)\n\nv_gravity = VariablePortedObject( # (1)!\n    name=\"v_gravity\",\n    assignments=[(\"v\", \"g\")], \n)\n\nv_drag = VariablePortedObject(\n    name=\"v_drag\",\n    assignments=[(\"v\", \"-mu * v**2\")],\n)\n\nf_drag = FunctionalPortedObject(\n    name=\"f_drag\",\n    assignments=[(\"mu\", \"frac_0(1/2 * C * rho * A, m, 0)\")], # (2)!\n)\n\nmodel = CompositePortedObject(\n    name=\"model\",\n    children=[v_gravity, v_drag, f_drag],\n    input_ports=[\"C\", \"rho\", \"A\", \"m\"],\n    variable_ports=[\"v\"],\n    directed_wires=[\n        (\"C\", \"f_drag.C\"),\n        (\"rho\", \"f_drag.rho\"),\n        (\"A\", \"f_drag.A\"),\n        (\"m\", \"f_drag.m\"),\n        (\"f_drag.mu\", \"v_drag.mu\"), \n    ],\n    variable_wires=[\n        ([\"v_gravity.v\", \"v_drag.v\"], \"v\")\n    ],\n)    \n\nfrac_0 = lambda a,b,d: a/b if b != 0 else d\n\nS = System()\nS.add_utility_function(name=\"frac_0\", function=frac_0)\nS.add_system_parameter(name=\"g\", function=9.81)\n\nS.set_object(model)\n</code></pre> <p>To create a simulation, use the method <code>S.create_simulation</code>. This method can be passed:</p> <ul> <li><code>name</code>, which if provided stores the simulation in <code>S.simulations</code>,</li> <li><code>solver</code>, which can be either <code>\"continuous\"</code> (default) or <code>\"discrete\"</code>, identifying the solver to use,</li> <li><code>initial_values</code>, which are the initial values of the variables in the simulation,</li> <li><code>input_parameters</code>, values for the parameters, if all are not already specified.</li> </ul> <p>For example, to simulate the system with an initial value <code>v = 0</code> and input parameters <code>{\"C\": 1.1, \"rho\": 1, \"A\": 0.2, \"m\": 2}</code>:</p> Running a simulation<pre><code>sim = S.create_simulation(initial_values = {\"v\": 0}, input_parameters={\"C\": 1.1, \"rho\": 1, \"A\": 0.2, \"m\": 2})\nsim.simulate(t_end=10)\n</code></pre>"},{"location":"user_guide/simulation/#plotting-a-solution","title":"Plotting a solution","text":"<p>A simple plot of the solution can be made with the <code>plot_solution</code> method.</p> <pre><code>sim.plot_solution()\n</code></pre> <p></p> <p>Running this checks that the model looks good, with the velocity of the object increasing from \\(0\\) up to a terminal velocity around \\(13.35 \\mathrm{ms}^{-1}\\).</p> <p>The time series used to plot each variable can also be accessed:</p> <pre><code>&gt;&gt;&gt; sim.variables[\"v\"].time_series\n[ 0.          0.97923946  1.94796176  2.89593846  3.81406616  4.69461378\n  5.531223    6.31890829  7.05405692  7.73442888  8.35915699  8.92874681\n  9.44516434  9.91112194 10.32931506 10.70265493 11.03427106 11.32751127\n 11.58594164 11.81334655 12.01362701 12.18970386 12.34379319 12.47806946\n 12.59467598 12.69572483 12.78329689 12.85944188 12.92614085 12.98463984\n 13.0355645  13.07955469 13.11728755 13.1494775  13.17687617 13.2002725\n 13.22049264 13.23840004 13.25452244 13.2687636  13.28116799 13.2918139\n 13.30081302 13.30831042 13.31448454 13.31954719 13.32374356 13.32735222\n 13.3306851  13.33401797 13.33717311 13.34004593 13.34258692 13.34476324\n 13.34655868 13.34797371 13.34902546 13.3497477  13.35019088 13.35042211\n 13.35052514 13.35060039 13.35076494 13.35115254 13.35177901 13.35246466\n 13.35315992 13.35382427 13.35442399 13.35493211 13.35532848 13.35559975\n 13.35573932 13.35574741 13.35563102 13.35540394 13.35508674 13.35470679\n 13.35429825 13.35390207 13.35356597 13.35334448 13.35329891 13.35348937\n 13.35376549 13.35403516 13.35428714 13.35451238 13.35470398 13.35485719\n 13.35496943 13.35504028 13.35507149 13.35506695 13.35503273 13.35497705\n 13.35491029 13.35484501 13.3547959  13.35477983]\n</code></pre>"},{"location":"user_guide/simulation/#next-steps","title":"Next steps","text":"<p>Many more examples of creating and simulating models in <code>psymple</code> can be found in the Examples section.</p>"},{"location":"user_guide/system/","title":"Creating a system","text":"<p>A <code>System</code> translates a model defined in a ported object into a system which can be simulated. In doing so, it provides context to the model, by telling it how to concretely interpret certain symbols and functions.</p>"},{"location":"user_guide/system/#contextualisation","title":"Contextualisation","text":"<p>The process of telling a model how to interpret symbols and functions is called contextualisation. There are three things that a system can contextualise:</p> <ul> <li>time: the symbol which represents the independent system variable which is simulated over,</li> <li>utility functions: which provide a system-wide definition of a function call,</li> <li>system parameters: which provide a system-wide definition of a symbol.</li> </ul> <p>The default symbol for time is <code>T</code>. When used in an assignment in a ported object, it is automatically not interpreted as a free symbol, and does not need associated ports to be defined.</p>"},{"location":"user_guide/system/#automatic-parsing-from-sympy","title":"Automatic parsing from <code>sympy</code>","text":"<p>Before getting to utility functions and system parameters, it is helpful to know that all assignments provided in <code>str</code> format in <code>psymple</code> are parsed using <code>sympy.parse_expr</code>. This accounts for a large number of common functions, most commonly:</p> <ul> <li>Trigonometric functions such as <code>sin</code> and <code>cos</code>, and their inverses, </li> <li>Hyperbolic functions such as <code>sinh</code> and <code>cosh</code> and their inverses,</li> <li>Mathematical functions such as <code>Min</code>, <code>Max</code>, <code>root</code> and <code>sqrt</code>,</li> <li>Integer functions such as <code>floor</code> and <code>ceiling</code>,</li> <li>Exponentials and logarithms,</li> <li>Piecewise functions.</li> </ul> <p>For example, writing the strings <code>\"sin(x)\"</code> or <code>\"log(x)\"</code> in assignments are interpreted as the symbolic functions <code>sin(x)</code> and <code>log(x)</code>, respectively. </p> <p>Certain symbols are also interpreted automatically. The full list of these is <code>['O', 'Q', 'N', 'I', 'E', 'S', 'beta', 'zeta', 'gamma', 'pi']</code>, and point to functions, constants, or other information in <code>sympy</code>. </p> <p>Single letter variables in <code>psymple</code></p> <p>There is currently no way of overriding the single symbols <code>['O', 'Q', 'N', 'I', 'E', 'S']</code> in <code>psymple</code>, and using them in assignments can lead to unexpected behaviour. It is best to avoid using these symbols in <code>psymple</code>, unless you are using them for their purpose in <code>sympy</code>. A planned feature will help deal with these symbols.</p>"},{"location":"user_guide/system/#utility-functions","title":"Utility functions","text":"<p>Utility functions supplement the functions that can already be interpreted by <code>sympy</code>. They can be simple, such as small <code>lambda</code> functions, or perform complex tasks, such as fetching information from data frames. In general, any callable function returning a single <code>float</code> value can be specified as a utility function.</p> <p>A simple lambda function</p> <p>A common function which becomes useful is ensuring simulations don't fail from division-by-zero. The function \\(\\mathrm{frac}_0\\) is defined by</p> \\[ \\mathrm{frac}_0(a,b,d) = \\begin{cases} \\frac{a}{b}, &amp; b \\ne 0, \\\\ d, &amp; b = 0. \\end{cases} \\] <p>Adding \\(\\mathrm{frac}_0\\) to a system is done as follows:</p> Adding a callable utility function<pre><code>from psymple.build import System\n\nfrac_0 = lambda a,b,d: a/b if b != 0 else d\n\nS = System()\nS.add_utility_function(name=\"frac_0\", function=frac_0) # (1)!\n</code></pre> <ol> <li>Like all <code>psymple</code> objects, the parameter <code>name</code> specifies how the object, in this case the function, is called in string inputs. </li> </ol> <p>Then, whenever <code>\"frac_0(x,y,z)\"</code> is used in an assignment, it is recognised as a symbolic function, and interpreted at the lambda function <code>frac_0</code> at simulation. </p> <p>Function arguments</p> <p>When adding a callable function as above, <code>psymple</code> determines the number of inputs the function should be provided. In the above example, entering <code>\"frac_0(x,y)\"</code> in an assignment will raise an error because the lambda function <code>frac_0</code> cannot be interpreted with just two arguments.</p> <p>Currently, default arguments, position-only arguments and keyword-only arguments are not fully supported. This is a planned feature.</p> <p>It is also possible to specify utility functions by specifying their symbolic representation. For example, a model temperature function \\(temp(t) = 10sin(t) + 20\\) can be added as follows:</p> Adding a symbolic utility function<pre><code>from psymple.build import System\n\nS = System()\nS.add_utility_function(name=\"temp\", function=\"10*sin(T) + 20\") # (1)!\n</code></pre> <ol> <li>By default, time is represented by symbol <code>T</code>.</li> </ol> <p>For more information on adding utility functions and syntax, see <code>add_utility_function</code>.</p>"},{"location":"user_guide/system/#system-parameters","title":"System parameters","text":"<p>System parameters are similar to utility functions, except they specify how certain symbols should be interpreted. A system parameter can represent a constant, such as the standard gravity constant on Earth is \\(g=9.81\\), or can be a function, whose arguments must be either:</p> <ul> <li>the system variable time,</li> <li>already existing system parameters.</li> </ul> <p>System parameters and input ports</p> <p>System parameters \"win\" over input ports of a ported object. If a system parameter <code>\"P\"</code> is specified and a port <code>\"P\"</code> is specified in a ported object, the port <code>\"P\"</code> will not be created, and a warning will be issued.</p> <p>Adding a system parameter to a system is similar to adding a utility function. For example, specifying the standard gravity constant can be done as follows:</p> Standard gravity<pre><code>from psymple.build import System\n\nS = System()\nS.add_system_parameter(\"g\", 9.81)\n</code></pre> <p>Then, whenever <code>\"g\"</code> is used in an assignment, it is recognised as a system parameter, and interpreted as \\(9.81\\) during simulation.</p> <p>As a second example suppose there are callable functions <code>t_max</code> and <code>t_min</code> which fetch the maximum and minimum temperature, respectively, on a given day from a dataframe of climate data. Since these only depend on time, they can be interpreted as system parameters as follows.</p> Maximum and minimum temperatures<pre><code>from psymple.build import System\n\ndef t_max(t) -&gt; float:\n    ...\n\ndef t_min(t) -&gt; float:\n    ...\n\nS = System()\nS.add_system_parameter(name=\"T_MAX\", function=t_max, signature=(\"T\",)) # (1)!\nS.add_system_parameter(name=\"T_MIN\", function=t_min, signature=(\"T\",))\n</code></pre> <ol> <li>The argument <code>signature=(\"T\",)</code> tells <code>psymple</code> that the system time symbol <code>T</code> should always be passed to <code>t_max</code>.</li> </ol> <p>Now that <code>\"T_MAX\"</code> and <code>\"T_MIN\"</code> are system parameters, additional system parameters can be defined based on their values. For example, the parameter <code>T_AVG = (T_MAX + T_MIN)/2</code> is defined as follows:</p> Average temperature<pre><code>S.add_system_parameter(\n    name=\"T_AVG\", \n    function=\"(T_MAX + T_MIN)/2\", \n    signature=(\"T_MAX\", \"T_MIN\"), # (1)!\n) \n</code></pre> <ol> <li>The argument <code>signature=(\"T_MAX\", \"T_MIN\")</code> tells <code>psymple</code> the order in which arguments should be displayed. It doesn't affect computation.</li> </ol> <p>For more information on adding system parameters and syntax, see <code>add_system_parameter</code>.</p>"},{"location":"user_guide/system/#setting-the-system-object","title":"Setting the system object","text":"<p>Once a system exists, a ported object can be imported and compiled in the context of the system. The goal of this process is to produce:</p> <ul> <li>A set of differential equations, one describing the evolution of each variable after compilation.</li> <li>A set of functions which define dependencies in the differential equations in terms of variables and, recursively, other functions.</li> </ul> <p>These two collections define a simulable system, which can be solved procedurally (not implemented), or numerically once all the dependencies have been substituted in terms of system variables.</p>"},{"location":"user_guide/system/#example","title":"Example","text":"<p>In the following example, this model of an object falling vertically, subject to gravitational and air resistance forces, is considered. The code can also be found by expanding the following block.</p> Falling object example Falling object with air resistance<pre><code>from psymple.build import (\n    FunctionalPortedObject, \n    VariablePortedObject,\n    CompositePortedObject,\n)\n\nv_gravity = VariablePortedObject( # (1)!\n    name=\"v_gravity\",\n    assignments=[(\"v\", \"g\")], \n)\n\nv_drag = VariablePortedObject(\n    name=\"v_drag\",\n    assignments=[(\"v\", \"-mu * v**2\")],\n)\n\nf_drag = FunctionalPortedObject(\n    name=\"f_drag\",\n    assignments=[(\"mu\", \"frac_0(1/2 * C * rho * A, m, 0)\")], # (2)!\n)\n\nmodel = CompositePortedObject(\n    name=\"model\",\n    children=[v_gravity, v_drag, f_drag],\n    input_ports=[\"C\", \"rho\", \"A\", \"m\"],\n    variable_ports=[\"v\"],\n    directed_wires=[\n        (\"C\", \"f_drag.C\"),\n        (\"rho\", \"f_drag.rho\"),\n        (\"A\", \"f_drag.A\"),\n        (\"m\", \"f_drag.m\"),\n        (\"f_drag.mu\", \"v_drag.mu\"), \n    ],\n    variable_wires=[\n        ([\"v_gravity.v\", \"v_drag.v\"], \"v\")\n    ],\n)    \n</code></pre> <ol> <li>The default input port for <code>\"g\"</code> has been removed. This will be replaced with a system parameter.</li> <li>The drag force is calculated using <code>frac_0</code>, see here, to allow for massless objects.</li> </ol> <p>The model has two changes:</p> <ol> <li>The default input port for <code>\"g\"</code> has been removed. This will be replaced with a system parameter.</li> <li>The drag force is calculated using <code>frac_0</code>, see here, to allow for massless objects. A system will tell <code>psymple</code> how to interpret this function using a utility function.</li> </ol> Falling object system<pre><code>from psymple.build import System\n\nfrac_0 = lambda a,b,d: a/b if b != 0 else d\n\nS = System()\nS.add_utility_function(name=\"frac_0\", function=frac_0)\nS.add_system_parameter(name=\"g\", function=9.81)\n\nS.set_object(model)\n</code></pre> <p>The call <code>S.set_object(model)</code>:</p> <ol> <li>Imports the ported object <code>model</code> into the system.</li> <li>Compiles it, and its child objects.</li> <li>Produces simulable variables and parameters.</li> </ol>"},{"location":"user_guide/system/#inspecting-the-system","title":"Inspecting the system","text":"<p>To get an idea of what was produced, once an object is added to a system, <code>print</code> can be called.</p> <p>System inspection</p> <p>Features for inspecting a system are not fully developed. Calling <code>print</code> is the easiest way of what is going on. More information can be gathered from inspecting the objects in the dictionaries <code>S.variables</code> and <code>S.parameters</code>. </p> Printing a system output<pre><code>&gt;&gt;&gt; print(S)\nsystem ODEs: ['dx_0/dt = -a_0*x_0**2 + g()'] \nsystem functions: ['a_0 = frac_0(a_1*a_2*a_3/2, a_4, 0)', 'a_1 = REQ', 'a_2 = REQ', 'a_3 = REQ', 'a_4 = REQ']\nvariable mappings: {v: x_0, T: t}\nparameter mappings: {f_drag.mu: a_0, C: a_1, rho: a_2, A: a_3, m: a_4}\n</code></pre> <p>The first two lines of the output give the ODEs and functions, respectively. The second two lines give mappings between the system identifiers and the \"readable symbols\" in the first two lines. Combining the above information the system is given by:</p> \\[ \\frac{dv}{dt} = g -\\mathrm{frac_0}\\left( \\frac{1}{2}C\\rho A, m, 0 \\right) v^2 = \\begin{cases} g - \\frac{C \\rho A}{2m} v^2, &amp; m \\ne 0, \\\\ g, &amp; m=0 \\end{cases} \\] <p>The outputs <code>'a_1 = REQ', 'a_2 = REQ', 'a_3 = REQ', 'a_4 = REQ'</code> indicate that the values of \\(C\\), \\(\\rho\\), \\(A\\) and \\(m\\) are required before simulation can occur.</p>"},{"location":"user_guide/system/#setting-input-parameters","title":"Setting input parameters","text":"<p>Setting parameter values is possible using the <code>set_parameters</code> method. Staying with the previous example:</p> Setting input parameters<pre><code>S.set_parameters({\"C\": 1.1, \"rho\": 1, \"A\": 0.2, \"m\": 2})\n</code></pre> <p>Now printing:</p> <pre><code>&gt;&gt;&gt; print(S)\nsystem ODEs: ['dx_0/dt = -a_0*x_0**2 + g()']\nsystem functions: ['a_0 = frac_0(a_1*a_2*a_3/2, a_4, 0)', 'a_1 = 1.10000000000000', 'a_2 = 1', 'a_3 = 0.200000000000000', 'a_4 = 2']\nvariable mappings: {v: x_0, T: t}\nparameter mappings: {f_drag.mu: a_0, C: a_1, rho: a_2, A: a_3, m: a_4}\n</code></pre> <p>Now all the parameters have been set correctly.</p>"},{"location":"user_guide/system/#simulating-the-system","title":"Simulating the system","text":"<p>Once a system has been created with a ported object, it can be simulated.</p>"}]}